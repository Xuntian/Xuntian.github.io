<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xuntian</title>
  
  <subtitle>Lizhiqiang&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lizq.top/"/>
  <updated>2019-07-18T06:57:35.795Z</updated>
  <id>http://www.lizq.top/</id>
  
  <author>
    <name>LiZhiqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gitlab性能监控</title>
    <link href="http://www.lizq.top/2019/07/18/CS/Git/gitlab%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>http://www.lizq.top/2019/07/18/CS/Git/gitlab性能监控/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T06:57:35.795Z</updated>
    
    <content type="html"><![CDATA[<p>Gitlab项目自带了非常完备的项目监控方案，在这里做一些简单的介绍。<br>官方文档里提到过下面几种监控</p><ul><li>Performance Bar</li><li>Monitoring GitLab with Prometheus</li><li>GitLab Performance Monitoring with Influxdb and Grafana</li></ul><a id="more"></a><h3 id="Performance-Bar"><a href="#Performance-Bar" class="headerlink" title="Performance Bar"></a>Performance Bar</h3><p>在Admin area中Settings &gt; Metrics and Profiling &gt; Profiling - Performance bar开启Performance Bar<br><img src="./performance_bar_configuration_settings.png" alt="performance_bar_configuration_settings"><br><img src="./performance_bar.png" alt="performance_bar"></p><p>这个监控功能很弱，只是用于在web页面端一次性显示本次访问的接口和时间开销</p><h3 id="Monitoring-GitLab-with-Prometheus"><a href="#Monitoring-GitLab-with-Prometheus" class="headerlink" title="Monitoring GitLab with Prometheus"></a>Monitoring GitLab with Prometheus</h3><p>gitlab自带好几个服务的心跳数据exporter，例如，node_exporter，redis_exporter和postgres_exporter；并且gitlab默认安装并开启了Prometheus服务，各类的exporters会将监控数据发送给Prometheus，所以只需要配置一下Prometheus就可以查看各类的监控数据了<br><figure class="hljs highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus['listen_address'] = ':<span class="number">9090</span>'</span><br><span class="line"><span class="meta"># or</span></span><br><span class="line">prometheus['listen_address'] = '0.0.0.0:<span class="number">9090</span>'</span><br></pre></td></tr></table></figure></p><p><img src="./prometheus.png" alt="prometheus"></p><h3 id="GitLab-Performance-Monitoring-with-Influxdb-and-Grafana"><a href="#GitLab-Performance-Monitoring-with-Influxdb-and-Grafana" class="headerlink" title="GitLab Performance Monitoring with Influxdb and Grafana"></a>GitLab Performance Monitoring with Influxdb and Grafana</h3><h4 id="配置influxdb"><a href="#配置influxdb" class="headerlink" title="配置influxdb"></a>配置influxdb</h4><figure class="hljs highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># influxdb配置文件</span></span><br><span class="line">[meta]</span><br><span class="line">  <span class="attr">dir</span> = <span class="string">"/var/lib/influxdb/meta"</span></span><br><span class="line"></span><br><span class="line">[data]</span><br><span class="line">  <span class="attr">dir</span> = <span class="string">"/var/lib/influxdb/data"</span></span><br><span class="line">  <span class="attr">engine</span> = <span class="string">"tsm1"</span></span><br><span class="line">  <span class="attr">wal-dir</span> = <span class="string">"/var/lib/influxdb/wal"</span></span><br><span class="line"></span><br><span class="line">[admin]</span><br><span class="line">  <span class="attr">enabled</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">  <span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line">  <span class="attr">auth-enabled</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[[udp]]</span><br><span class="line">  <span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line">  <span class="attr">bind-address</span> = <span class="string">":8089"</span></span><br><span class="line">  <span class="attr">database</span> = <span class="string">"gitlab"</span></span><br><span class="line">  <span class="attr">batch-size</span> = <span class="number">1000</span></span><br><span class="line">  <span class="attr">batch-pending</span> = <span class="number">5</span></span><br><span class="line">  <span class="attr">batch-timeout</span> = <span class="string">"1s"</span></span><br><span class="line">  <span class="attr">read-buffer</span> = <span class="number">209715200</span></span><br></pre></td></tr></table></figure><p>用docker启动influxdb，加入存放配置文件的volume，开放8089（udp，用于gitlab推送数据），8086（grafana访问数据），8083（admin panel)<br><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --name influxdb -v influxdb<span class="selector-class">.conf</span>:/etc/influxdb/influxdb<span class="selector-class">.conf</span>:ro \</span><br><span class="line">    -<span class="selector-tag">p</span> <span class="number">8089</span>:<span class="number">8089</span>/udp -<span class="selector-tag">p</span> <span class="number">8086</span>:<span class="number">8086</span> -<span class="selector-tag">p</span> <span class="number">8083</span>:<span class="number">8083</span> \</span><br><span class="line">    -e INFLUXDB_ADMIN_ENABLED=true \</span><br><span class="line">    -e INFLUXDB_ADMIN_USER=&#123;user&#125; \</span><br><span class="line">    -e INFLUXDB_ADMIN_PASSWORD=&#123;passwd&#125; \</span><br><span class="line">    influxdb</span><br></pre></td></tr></table></figure></p><h4 id="配置gitlab"><a href="#配置gitlab" class="headerlink" title="配置gitlab"></a>配置gitlab</h4><p>在Admin area中的Settings &gt; Metrics做如下配置，influxDB host按自己的情况填写<br><img src="./metrics_gitlab_configuration_settings.png" alt="metrics_gitlab_configuration_settings"><br>然后gitlab-ctl restrat 重启gitlab的各项服务</p><h3 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h3><p>同样的，用docker启动grafana<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -dti <span class="comment">--name grafana -p 3000:3000 -e GF_SECURITY_ADMIN_PASSWORD=&#123;passwd&#125; grafana/grafana</span></span><br></pre></td></tr></table></figure></p><p>启动后在grafana的web界面根据influxdb的配置添加influxdb的数据源，就可以在dashboard中看到gitlab的监控数据了<br><img src="./grafana.png" alt="grafana"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gitlab项目自带了非常完备的项目监控方案，在这里做一些简单的介绍。&lt;br&gt;官方文档里提到过下面几种监控&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Performance Bar&lt;/li&gt;
&lt;li&gt;Monitoring GitLab with Prometheus&lt;/li&gt;
&lt;li&gt;GitLab Performance Monitoring with Influxdb and Grafana&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="application" scheme="http://www.lizq.top/categories/CS/application/"/>
    
      <category term="gitlab" scheme="http://www.lizq.top/categories/CS/application/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://www.lizq.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Gitaly</title>
    <link href="http://www.lizq.top/2019/07/18/CS/Git/gitaly/"/>
    <id>http://www.lizq.top/2019/07/18/CS/Git/gitaly/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T07:01:23.773Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇关于gitlab集群搭建的文章，之前gitlab集群搭建起来之后性能很差，网页打开速度比较慢。从gitlab9.1版本后gitlab官方发布了gitaly项目，以解决gitlab-rails性能问题。</p><a id="more"></a><h2 id="gitaly简述"><a href="#gitaly简述" class="headerlink" title="gitaly简述"></a>gitaly简述</h2><p><img src="./p1.png" alt="传统架构示意图"></p><p>在之前，上层应用使用libgit2库调用底层的git，libgit2由c语言开发，gitlab-rails使用ruby的Rugged调用libgit2和git通信。而存储层则使用性能很差的nfs，网络文件系统增大了文件访问的开销，同时git也无法利用缓存增加平均访问速度。</p><p><img src="./p2.png" alt="gitaly架构示意图"></p><p>gitaly发布之后，gitlab-rails通过grpc访问gitaly和底层的git通信，规避了nfs的开销，可以对存储进行批量扩展，gitlab和gitaly的配置如下：</p><blockquote><p>gitlab</p></blockquote><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/gitlab/gitlab.rb</span></span><br><span class="line">git_data_dirs(&#123;</span><br><span class="line">  <span class="string">'default'</span> =&gt; &#123; <span class="string">'gitaly_address'</span> =&gt; <span class="string">'tcp://gitaly.internal:8075'</span> &#125;,</span><br><span class="line">  <span class="string">'storage1'</span> =&gt; &#123; <span class="string">'gitaly_address'</span> =&gt; <span class="string">'tcp://gitaly.internal:8075'</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">'gitaly_token'</span>] = <span class="string">'abc123secret'</span></span><br></pre></td></tr></table></figure><blockquote><p>gitaly</p></blockquote><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/gitlab/gitlab.rb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avoid running unnecessary services on the Gitaly server</span></span><br><span class="line">postgresql[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">redis[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">nginx[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">prometheus[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">unicorn[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">sidekiq[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line">gitlab_workhorse[<span class="string">'enable'</span>] = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prevent database connections during 'gitlab-ctl reconfigure'</span></span><br><span class="line">gitlab_rails[<span class="string">'rake_cache_clear'</span>] = <span class="keyword">false</span></span><br><span class="line">gitlab_rails[<span class="string">'auto_migrate'</span>] = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the gitlab-shell API callback URL. Without this, `git push` will</span></span><br><span class="line"><span class="comment"># fail. This can be your 'front door' GitLab URL or an internal load</span></span><br><span class="line"><span class="comment"># balancer.</span></span><br><span class="line"><span class="comment"># Don't forget to copy `/etc/gitlab/gitlab-secrets.json` from web server to Gitaly server.</span></span><br><span class="line">gitlab_rails[<span class="string">'internal_api_url'</span>] = <span class="string">'https://gitlab.example.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make Gitaly accept connections on all network interfaces. You must use</span></span><br><span class="line"><span class="comment"># firewalls to restrict access to this address/port.</span></span><br><span class="line">gitaly[<span class="string">'listen_addr'</span>] = <span class="string">"0.0.0.0:8075"</span></span><br><span class="line">gitaly[<span class="string">'auth_token'</span>] = <span class="string">'abc123secret'</span></span><br><span class="line"></span><br><span class="line">gitaly[<span class="string">'storage'</span>] = [</span><br><span class="line">  &#123; <span class="string">'name'</span> =&gt; <span class="string">'default'</span>, <span class="string">'path'</span> =&gt; <span class="string">'/mnt/gitlab/default/repositories'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'name'</span> =&gt; <span class="string">'storage1'</span>, <span class="string">'path'</span> =&gt; <span class="string">'/mnt/gitlab/storage1/repositories'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇关于gitlab集群搭建的文章，之前gitlab集群搭建起来之后性能很差，网页打开速度比较慢。从gitlab9.1版本后gitlab官方发布了gitaly项目，以解决gitlab-rails性能问题。&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="application" scheme="http://www.lizq.top/categories/CS/application/"/>
    
      <category term="gitlab" scheme="http://www.lizq.top/categories/CS/application/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://www.lizq.top/tags/gitlab/"/>
    
      <category term="gitaly" scheme="http://www.lizq.top/tags/gitaly/"/>
    
  </entry>
  
  <entry>
    <title>金融的逻辑</title>
    <link href="http://www.lizq.top/2019/06/24/EM/%E6%8A%95%E8%B5%84/%E9%87%91%E8%9E%8D%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    <id>http://www.lizq.top/2019/06/24/EM/投资/金融的逻辑/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-06-25T12:08:37.389Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一本书《金融的逻辑》，这是关于一本叙述金融是什么的书，以前我们都是说金融金融的，却不知道金融背后的逻辑是什么，为什么会有金融出现，对社会经济发展有什么作用。这本书较为深刻地说清楚了这些问题。</p><blockquote><p>金融的本质是资源的交易与调配，最符合利益的调配和跨时间空间的交易。</p></blockquote><a id="more"></a><h3 id="1，钱、资本和财富和他们之间的关系"><a href="#1，钱、资本和财富和他们之间的关系" class="headerlink" title="1，钱、资本和财富和他们之间的关系"></a>1，钱、资本和财富和他们之间的关系</h3><ul><li>钱主要是一个货币的概念，流动性最好，可直接用于交换，并同时又是市场交换的结果，是最为普遍的价值载体</li><li>资本是活的价值，是能生产价值的价值，能够转换成资产，用于增值的，资本包括钱，比钱描述的范围更大一些</li><li>财富则包括资本，是描述范围最大的，包括流动性和固定的价值</li><li>从契约理论的角度讲，财富往往是物，是东西，货币（钱）是把东西卖掉之后的价值载体，而资本则更多地是东西的产权。</li><li>什么东西可以算是财富呢，财富的价值又由什么决定呢？财富可以说是能满足人们需求的物品，其价值由买方决定，也就是由需求而定，并不是由生产这件物品所消耗的成本决定。</li><li>是什么决定财富的多少呢？一是物产的富饶程度，这是大自然赠予的；二是生产力的发达程度，工商业发达的国家自然拥有更多的财富，能生产出更多满足人们需求的物品和提供人们所需要的服务。</li><li>财富不一定能一下子变成钱，财富的范围比资本大，资本的范围比钱大。一个国家对“东西”、对未来收入流进行资本化的能力，也就是市场化、资本化的能力和契约与产权制度的完善程度决定了这三者间的距离。</li></ul><h3 id="2，中国的钱为什么那么多"><a href="#2，中国的钱为什么那么多" class="headerlink" title="2，中国的钱为什么那么多"></a>2，中国的钱为什么那么多</h3><ul><li>现在中国人的钱很多，买房有钱，投资有钱，有钱人很多。但这到底是怎么回事？</li><li>一方面是物产富饶，生产力水平显著提高</li><li>还有一个重要的原因是市场化，市场化使中国的钱变多了，一个国家可以卖的东西越多，或者已经资本化或能够被资本化的资产和未来的收入流越多，钱就会越多</li><li>还有一个更重要的原因是资本化，市场化只是缩短了财富和钱之间的距离，而资本化则使很多非实体物品进行与钱之间的转化，可以讲企业或者个人未来的收入流、土地和自然资源转化为资本等</li><li>资本化的前提是资本源的产权被明确界定，能被交易，能以产权契约的形式自由买卖，改革开放前的中国是一个有财富但没有资本的社会，因为没有进行市场化和资本化</li><li>美国社会为什么那么有钱，就是因为其市场化和资本化的程度相当高，高度金融化带来的是充足的金融资本供给，用于科技创新，对外投资，个人创业，以促进生产力和服务的提高</li><li>资本化是中国经济未来增长的主要推动力</li></ul><h3 id="3，为什么中国钱多了许多人却不感到富有"><a href="#3，为什么中国钱多了许多人却不感到富有" class="headerlink" title="3，为什么中国钱多了许多人却不感到富有"></a>3，为什么中国钱多了许多人却不感到富有</h3><ul><li>过去的中国是依靠传统文化的亲情友情间的互助式隐性金融解决集资问题，如礼尚往来，养儿防老等</li><li>金融制度、工具和市场的发展不足，导致中国人大多还是依靠储蓄防范未来的风险，而储蓄在通货膨胀下被不断稀释</li><li>传统互助互惠的隐性金融交易随着现代社会的发展被逐渐弱化，而显性的金融保险、信贷、养老、投资产品发展相对滞后，钱多的同时对未来感到不安，使内需无法增长，结果就是中国经济增长继续依赖出口，幸福感下降</li><li>依靠传统文化的亲情友情间的互助式隐性金融正在由显性金融交易的形式所取代</li><li>儒家文化导致保守的消费观念和落后的金融市场和制度</li></ul><h3 id="4，西方国家的崛起与金融市场的关系"><a href="#4，西方国家的崛起与金融市场的关系" class="headerlink" title="4，西方国家的崛起与金融市场的关系"></a>4，西方国家的崛起与金融市场的关系</h3><ul><li>17世纪至19世纪，西方国家的崛起本质上并不是因为掠夺，因为在相当长一段时期，中国对西方国家是处于贸易优势的，这也是鸦片战争的起因</li><li>在西方工业革命期间，英法美等国政府的赤字在不断地扩大，而同时中国明清两朝的国库却经常有较大的盈余</li><li>英国的崛起是因为债券市场的高度发达，将政府未来的收入提前变现，用于现在的资本扩张；谁能以更低的成本把更多的未来收入作证券化变现，谁就能拥有更多的发展机会</li><li>美国建国初期，政府负债累累，通过中央集权，统一债券发行，获得了很多的借款才得以发展</li><li>资本化是美国资本主义的核心精神，美国真正的崛起是由于股市的繁荣，美国的长足进步靠的是科技创新，而科技创新需要大量的风险资金，股市正好可以提供大量的风险资金支持其科技进步</li><li>金融市场繁荣的基石是完善的制度</li><li>人一生中消费需求和收入是不匹配的，年轻时往往消费需要较多，而收入却不高；中国是通过父辈与子女之间的关系解决这个问题，美国则是靠完善的信用制度，这刺激了内需，促进了经济的增长</li></ul><h3 id="5，治国的金融之道"><a href="#5，治国的金融之道" class="headerlink" title="5，治国的金融之道"></a>5，治国的金融之道</h3><ul><li>明清两朝在末期都是由于空库亏空导致的经济危机而灭亡，完善的金融制度和市场可以扩宽政府的融资渠道，增强应对危机的能力，使改朝换代的概率降低</li><li>国家持续增长的启示是政府敢于借钱花，当资本回报率高于借款利率时，可以维持国家经济的持续增长</li><li>储蓄反而会抑制国家的发展</li><li>当国家或政府遭遇危机时，明清政府的做法是加税，这恰恰会加重危机</li><li>缓解财政危机的办法：一是发债，二是货币手段</li><li>需要注意的是，98年亚洲金融危机期间，由于制度的不完善，缺乏对权力的约束，黑箱操作滋生腐败，政府财政和外债被当权者私用</li><li>中国在清末的洋务运动和民国时期有过金融市场的萌芽，最终因政府公信力不足和制度缺乏权威性和完善性导致失败</li></ul><h3 id="6，中国股市的问题"><a href="#6，中国股市的问题" class="headerlink" title="6，中国股市的问题"></a>6，中国股市的问题</h3><ul><li>承载资产产权的金融票据资产间的距离不能太远，否则票据和资产脱钩之后，就和赌博无本质区别了</li><li>自由开放媒体的缺失</li><li>缺乏合理的制度对操纵信息、对以虚假信息操纵股价的人绳之以法</li><li>政府对股市干预太多</li><li>股市应该是企业发展的融资平台，却和很多地方政府有较多的利益挂钩</li><li>法制建设的落后</li></ul><h3 id="7，发展证券金融是中国唯一的出路"><a href="#7，发展证券金融是中国唯一的出路" class="headerlink" title="7，发展证券金融是中国唯一的出路"></a>7，发展证券金融是中国唯一的出路</h3><ul><li>市场经济是个人解放的必由之路，现在的年轻人是既想要西方的自由，又不想承担社会责任；而解决办法就是年轻人自己通过按揭贷款买房结婚，自己以后赚钱了还银行，父母自己把积蓄买理财解决养老问题</li><li>儒家文化所依赖的社会结构土壤已经破裂，家庭的重点在感情需求，经济交换功能从家庭里剥离出来</li><li>金融的发展对社会，国家和个人的发展至关重要</li><li>社会的发展本质是生产力的提高，是靠科技创新促进生产力的进步，科技创新是有很大风险的，需要大量的风险资金，股市的投机性给科技创新提供了资金</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一本书《金融的逻辑》，这是关于一本叙述金融是什么的书，以前我们都是说金融金融的，却不知道金融背后的逻辑是什么，为什么会有金融出现，对社会经济发展有什么作用。这本书较为深刻地说清楚了这些问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金融的本质是资源的交易与调配，最符合利益的调配和跨时间空间的交易。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="EM" scheme="http://www.lizq.top/categories/EM/"/>
    
      <category term="价值投资" scheme="http://www.lizq.top/categories/EM/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="投资" scheme="http://www.lizq.top/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="金融的逻辑" scheme="http://www.lizq.top/tags/%E9%87%91%E8%9E%8D%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>HPA</title>
    <link href="http://www.lizq.top/2018/12/20/CS/Kubernetes/hpa/"/>
    <id>http://www.lizq.top/2018/12/20/CS/Kubernetes/hpa/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-04-14T14:30:33.952Z</updated>
    
    <content type="html"><![CDATA[<p>HPA自动水平伸缩，可以根据资源使用率进行自动扩容、缩容pod的数量。根据 CPU 使用率或自定义 metrics 自动扩展 Pod 数量（支持 replication controller、deployment）；k8s1.6版本之前是通过kubelet来获取监控指标，1.6版本之后是通过api server、heapster或者kube-aggregator来获取监控指标。<br><a id="more"></a></p><h3 id="Metrics支持"><a href="#Metrics支持" class="headerlink" title="Metrics支持"></a>Metrics支持</h3><p>根据不同版本的API中，HPA autoscale时靠以下指标来判断资源使用率： </p><ul><li>autoscaling/v1: CPU</li><li>autoscaling/v2alpha1 <ul><li>内存</li><li>自定义metrics</li><li>多metrics组合: 根据每个metric的值计算出scale的值，并将最大的那个值作为扩容的最终结果</li></ul></li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>k8s环境基于k8s 1.9，仅使用autoscaling/v1 版本API，注意确保k8s 集群插件kubedns 和 heapster 工作正常。</p><figure class="hljs highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl top <span class="keyword">node</span>   <span class="title"># 检测heapster</span>是否正常</span><br></pre></td></tr></table></figure><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="bullet">-f</span> <span class="string">deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">dw-gateway</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">dw-gateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">dw-gateway</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">dw-gateway</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">xuntian/dw-gateway</span></span><br><span class="line"><span class="attr">          imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">              protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          livenessProbe:</span></span><br><span class="line"><span class="attr">            httpGet:</span></span><br><span class="line"><span class="attr">              path:</span> <span class="string">/test</span></span><br><span class="line"><span class="attr">              port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          readinessProbe:</span></span><br><span class="line"><span class="attr">            httpGet:</span></span><br><span class="line"><span class="attr">              path:</span> <span class="string">/test</span></span><br><span class="line"><span class="attr">              port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><figure class="hljs highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f hpa.yaml</span><br><span class="line"></span><br><span class="line"><span class="symbol">apiVersion:</span> autoscaling/v1</span><br><span class="line"><span class="symbol">kind:</span> HorizontalPodAutoscaler</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> dw-gateway-master-zh-cn</span><br><span class="line"><span class="symbol">  namespace:</span> default</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  maxReplicas:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  minReplicas:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">  scaleTargetRef:</span></span><br><span class="line"><span class="symbol">    apiVersion:</span> apps/v1</span><br><span class="line"><span class="symbol">    kind:</span> Deployment</span><br><span class="line"><span class="symbol">    name:</span> dw-gateway-master-zh-cn</span><br><span class="line"><span class="symbol">  targetCPUUtilizationPercentage:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>利用jmeter或其他工具对pod进行压力测试<br><figure class="hljs highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get hpa -o wide</span><br><span class="line">NAME                      REFERENCE                            TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">dw-gateway-master-zh-cn   Deployment/dw-gateway-master-zh-cn   <span class="number">0</span>% / <span class="number">30</span>%   <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">17</span>h</span><br><span class="line"></span><br><span class="line"># kubectl get hpa -o wide</span><br><span class="line">NAME                      REFERENCE                            TARGETS     MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">dw-gateway-master-zh-cn   Deployment/dw-gateway-master-zh-cn   <span class="number">61</span>% / <span class="number">30</span>%   <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"># kubectl get hpa -o wide</span><br><span class="line">NAME                      REFERENCE                            TARGETS     MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">dw-gateway-master-zh-cn   Deployment/dw-gateway-master-zh-cn   <span class="number">61</span>% / <span class="number">30</span>%   <span class="number">1</span>         <span class="number">10</span>        <span class="number">3</span>          <span class="number">17</span>h</span><br><span class="line"></span><br><span class="line"># kubectl get hpa -o wide</span><br><span class="line">NAME                      REFERENCE                            TARGETS     MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">dw-gateway-master-zh-cn   Deployment/dw-gateway-master-zh-cn   <span class="number">36</span>% / <span class="number">30</span>%   <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">17</span>h</span><br></pre></td></tr></table></figure></p><blockquote><p>停止压测，REPLICAS的数量将逐渐降为1</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HPA自动水平伸缩，可以根据资源使用率进行自动扩容、缩容pod的数量。根据 CPU 使用率或自定义 metrics 自动扩展 Pod 数量（支持 replication controller、deployment）；k8s1.6版本之前是通过kubelet来获取监控指标，1.6版本之后是通过api server、heapster或者kube-aggregator来获取监控指标。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="k8s" scheme="http://www.lizq.top/categories/CS/k8s/"/>
    
      <category term="hpa" scheme="http://www.lizq.top/categories/CS/k8s/hpa/"/>
    
    
      <category term="k8s" scheme="http://www.lizq.top/tags/k8s/"/>
    
      <category term="hpa" scheme="http://www.lizq.top/tags/hpa/"/>
    
  </entry>
  
  <entry>
    <title>Pause容器</title>
    <link href="http://www.lizq.top/2018/12/20/CS/Kubernetes/Pause/"/>
    <id>http://www.lizq.top/2018/12/20/CS/Kubernetes/Pause/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-08-22T08:16:07.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在k8s集群正常运行的pod中，可以看到每个应用pod都对应有一个pause的docker容器，那么这个容器有什么作用呢？</p></blockquote><blockquote><p>k8s通过对每个容器的命名空间配置，将Pod的网络、进程以及进程间通信命名空间都统一到pause的容器中。命名空间是Liunx内核的一个功能，是指从虚拟机层面上对机器的资源进行分组隔离，使用相同命名空间的每个容器都共享一套资源。使用相同命名空间的Pod容器，在各自应用内调用请求就像在本机中互相访问一样，这样资源的调度单位就非常巧妙地变为了Pod。</p></blockquote><a id="more"></a><blockquote><p>在Linux系统启动时，任何进程都是由第一个进程init派生出来的，因此在正常的情况下，它们都拥有相同的命名空间。当一个进程结束或者异常退出时，其父进程负责处理它的返回结果，以让操作系统正常回收其进程空间。</p></blockquote><blockquote><p>但也有一些其他的情况，比如父进程没有很好的处理子进程的退出情况，就是说没有调用wait命令来处理其返回代码，其原因可能是代码写得不好或者意外崩溃了。</p></blockquote><blockquote><p>此时，操作系统会将失去父进程的进程挂到PID为1的进程下，一般场景下就是init进程，而这种进程就被成为Orphan Process。在docker容器中，每个容器具有独立的命名空间，其应用进程自身就是第一个进程，PId=1,如果应用进程的子进程又调用fork或者exec参数创建了更多的子进程，那么当出现问题时，它们就会被挂到应用进程下，应用进程和init不一样，并没有处理僵尸进程的逻辑。</p></blockquote><blockquote><p>于是pause的作用就是处理子进程返回时的各种信号，以让其顺利退出。它的代码也非常简单，使用C语言编写，如下<br><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIFY(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_STRING(x) STRINGIFY(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VERSION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION HEAD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigdown</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">  psignal(signo, <span class="string">"Shutting down, got signal"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigreap</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(argv[i], <span class="string">"-v"</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"pause.c %s\n"</span>, VERSION_STRING(VERSION));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getpid() != <span class="number">1</span>)</span><br><span class="line">    <span class="comment">/* Not an error because pause sees use outside of infra containers. */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Warning: pause should be the first process\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigaction(SIGINT, &amp;(struct sigaction)&#123;.sa_handler = sigdown&#125;, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (sigaction(SIGTERM, &amp;(struct sigaction)&#123;.sa_handler = sigdown&#125;, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;(struct sigaction)&#123;.sa_handler = sigreap,</span><br><span class="line">                                             .sa_flags = SA_NOCLDSTOP&#125;,</span><br><span class="line">                <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    pause();</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: infinite loop terminated\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>从代码中可以看出，pause在启动时向系统注册了两个系统信号回调函数（sigdown, sigreap）后，便进入了无止境的睡眠，其中sigdown只是简单地处理任务终止请求，sigreap则调用系统wait命令来接管每个孤儿进程，当其退出时及时在进程表中做好清除标记，以让操作系统回收相关资源。pause是一个资源汇集平台，将Pod中的各类资源打通并形成统一的部署结构，更有利于微服务集群管理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在k8s集群正常运行的pod中，可以看到每个应用pod都对应有一个pause的docker容器，那么这个容器有什么作用呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;k8s通过对每个容器的命名空间配置，将Pod的网络、进程以及进程间通信命名空间都统一到pause的容器中。命名空间是Liunx内核的一个功能，是指从虚拟机层面上对机器的资源进行分组隔离，使用相同命名空间的每个容器都共享一套资源。使用相同命名空间的Pod容器，在各自应用内调用请求就像在本机中互相访问一样，这样资源的调度单位就非常巧妙地变为了Pod。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="k8s" scheme="http://www.lizq.top/categories/CS/k8s/"/>
    
      <category term="pause" scheme="http://www.lizq.top/categories/CS/k8s/pause/"/>
    
    
      <category term="k8s" scheme="http://www.lizq.top/tags/k8s/"/>
    
      <category term="pause" scheme="http://www.lizq.top/tags/pause/"/>
    
  </entry>
  
  <entry>
    <title>传世书</title>
    <link href="http://www.lizq.top/2018/11/16/EM/%E6%8A%95%E8%B5%84/%E4%BC%A0%E4%B8%96%E4%B9%A6/"/>
    <id>http://www.lizq.top/2018/11/16/EM/投资/传世书/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2019-04-15T07:10:05.621Z</updated>
    
    <content type="html"><![CDATA[<p>数月前有幸读了关善祥老师的《传世书》，感受颇多，撰一文以记之。</p><h3 id="传世家书"><a href="#传世家书" class="headerlink" title="传世家书"></a>传世家书</h3><p>贫穷就像传染病，传染了一代又一代人。通过投资的方式，家族财富以复利增长，以此为家风流传后世，为家族谋发展。日本有很多工匠家族，专注技艺，将工匠精神一直流传；投资也可以成为一种技艺，一种精神，一种思想流传给后代子孙，使家族事业长青。<br><a id="more"></a></p><h3 id="一，投资永生，万世常青"><a href="#一，投资永生，万世常青" class="headerlink" title="一，投资永生，万世常青"></a>一，投资永生，万世常青</h3><p>这个世界最确定的事情就是死亡，任何事业都有终结的一天。当一类新的需求被发掘，与之匹配的行业就开始兴起，每个行业都有它的时代属性，时代一过，这个行业就随着消亡。而我们的目标就是基业长青，把事业世世代代传承下去。投资这个事业就可以达到这个目标，通过投资将家族事业寄生在蓬勃发展的行业里，在投资的行业走向没落时及时退出，投资到下一个新兴的行业中去。</p><h3 id="二，窥破万象，看透本质"><a href="#二，窥破万象，看透本质" class="headerlink" title="二，窥破万象，看透本质"></a>二，窥破万象，看透本质</h3><p>事物的发展，归根到底是人类自身的发展。尽管有战争，疾病等等各种灾难，人类总体都是不断地向前发展，人类就是这样一个永远追求向上的种族。人类的命运是由少数精英分子决定的，由精英群体，形成组织，领导起其他的人才，组织各种资源，进行生产服务，推动社会的发展。这个组织就是企业，企业就是人类中的精英群体。上市公司就是企业中的精英，而优秀的上市公司就是精英中的精英。投资人类，就是要投资精英中的精英，就是优秀的上市公司。只有少数优秀的上市掌握了最好的人力，财力，物力资源，提供更好的生产和服务，赚取更多的利润。</p><p>优秀的企业上市，使公司权益证券化，于是产生了股票。股票是一个伟大的工具，具有诸多优点。假如你想要创业，你需要怎么办呢？首先是筹集一大笔资金，建设厂房，聘请技术工人，购买原材料，然后产品设计，生成组转，仓储运输，营销渠道，最后是零售等等。这一过程需要很长的时间周期，等你的产品生成出来了，说不定很快就被时代淘汰，和第一点说的一样，任何行业都有没落的一天，等到没落的时候，实体企业很难整体打包切换到另一个新兴的行业，比如做服装的企业，如果想要切换到生产电器的企业，那就需要将服装企业的所有固定资产全部卖掉，辞退员工，解散公司，折成现金，然后新创办企业流程再走一遍，要付出巨大的清算折旧成本和时间成本。而通过股票则快捷方便得多，卖出服装企业的股票，转手就可以买入电器公司的股票。所以，股票具有以下优点，</p><ul><li>股票的本质就是一个生意，相当于拥有了一家企业的一部分，拥有投票权和享受分红的权利</li><li>超级选择权，任何已经上市的企业都可以选择，包括一些实体创业有很高门槛的行业，比如银行，电力，交通等国家垄断的行业</li><li>超级流动性，可以在不同行业不同企业之间快速切换，很容易变卖，像上面的例子实体企业在变卖清算时很可能没人接盘</li><li>以非常便宜的价格买到优质的资产，股票是有周期的，在熊市的时候，大部分企业的价格往往非常便宜</li></ul><p>长期来看，货币始终处于超发状态，在缓慢地贬值，把钱存银行就是在为银行和国家打工，所以必须投资理财。以下是美国过去100年各类资产的投资回报率，股票整体的平均投资回报率是可以轻松跑赢通胀的。<br><img src="./p1.jpg" alt="投资回报率"></p><h3 id="三，开源节流，百年复利"><a href="#三，开源节流，百年复利" class="headerlink" title="三，开源节流，百年复利"></a>三，开源节流，百年复利</h3><p>勤俭节约是美德，投资需要一定的本金，勤俭的品质为家族积累原始资金。哪怕因意外损失所有资产，依靠勤俭仍然可以从头再来，积累资金用于投资。<br>人的收入一般分为主动收入和被动收入，主动收入就是工作以赚钱薪水，这个一般根据你的能力、经验和掌握的资源来决定，主动收入是先上涨，然后慢慢下跌，直到为零的。而被动收入则是通过投资理财赚钱收益，这个收益是可以随着时间不断地复利增长的，会越来越多的。复利的指数增长具有巨大的增长性，长久下去，回报惊人。</p><h3 id="四，好玉有价，成长难测"><a href="#四，好玉有价，成长难测" class="headerlink" title="四，好玉有价，成长难测"></a>四，好玉有价，成长难测</h3><p>投资的全部就是以低估买入优秀的公司，耐心持有，高估卖出。那么投资就需要判断这个公司是否拥有一个好的生意模式，即判断这是家好公司，和判断当前的股价的高低。好投资=好公司+好价格。过高的估值和平庸的公司都是坚决避免的，好公司在过高的估值下买入，将要耗费漫长的时间去消化掉高估值。低估值不一定对，因为这可能是家走下坡路的企业，但高估值肯定就是错误，除非像早年间的腾讯等科技企业，业绩增长迅猛，足可以短时间内消化掉过高的估值，也就是具有很高的成长价值。这就是经常争论的是价值投资好，还是成长投资好。价值股的定义是估值比较便宜，但业绩增长慢；成长股是估值比较高，但是业绩增长快。<br>选出已经成功的公司比较容易，因为已经在成熟的行业占据龙头地位，但这些公司往往增长缓慢，或者没有什么增长，这类公司只需要在其低估时买入即可。在选择成长性的公司很难，以为很多高成长不一定可持续，往往今年获得了很大的增长，下一年就可能停止成长，甚至亏损，未来都是不确定的。<br>而对于投资来说，稳定压倒一切，高成长的公司有太多的不确定性，而且真正具有高成长的企业往往很难遇到，两者相比，显然价值股投资更加确定，难度低，风险更小。</p><h3 id="五，永不负债，永不做空"><a href="#五，永不负债，永不做空" class="headerlink" title="五，永不负债，永不做空"></a>五，永不负债，永不做空</h3><p>永远不借钱投资，借钱投资就是上杠杆，涨的时候赚的多，跌的时候亏的更多，哪怕是最低的1：1的杠杆，只要股价下跌50%就得爆仓，而市场先生的情绪谁也无法预测，下跌个30%，50%的很正常。一用杠杆，可能会在一次大幅回调中就葬送掉今后的投资生涯。<br>纵观世界各国历史，其实属于投资的时代非常有限，美国过去的50多年算是一个很好的投资时代，国运稳定向上，经济不断发展，于是股市稳定增长。所以，投资就是赌国运，国运向上，投资取得优厚回报的可能性就会更大。<br>另一方面，股价往往向下空间有限，但向上空间却很大，可以翻很多倍，像茅台，格力，伊利等公司，增长了几百倍。如果你做空，而股价向上的增长就可能导致你负债，葬送掉之前的所有本金，非常危险。</p><h3 id="六，避重就轻，险地勿入"><a href="#六，避重就轻，险地勿入" class="headerlink" title="六，避重就轻，险地勿入"></a>六，避重就轻，险地勿入</h3><p>假如我知道自己死在哪里，那我就一辈子不娶那里。我们的投资是投资一个已经成功的公司，并且会持续成功的公司，至少不会衰落得太快，在衰落之前有足够得时间撤离。<br>要追求那些可以不断复利的资产，投入轻但是回报大的企业，避开那些重资产的公司，也就是净资产收益率ROE要高。<br>险地勿入，有危险的，不懂公司的商业模式，不懂公司文化的，那些所谓的亏损重组，收购，题材炒作多要坚决避免。</p><h3 id="七，无视波动，价值前行"><a href="#七，无视波动，价值前行" class="headerlink" title="七，无视波动，价值前行"></a>七，无视波动，价值前行</h3><p>股价波动的本质，是人性贪婪与恐惧的交织。股票的本质是公司，公司的价值是比较稳定的，公司还是那个公司，但股价往往时时刻刻都在变化。价值投资，没有止损一说。波动是正常的现象，股价的下跌，不会造成真实的亏损，真实的亏损是背后的公司盈利能力的下降，这个时候才需要清仓。价值投资者在发现股价严重高估，已经透支了公司好多年之后的利润增长，或者发现公司的盈利能力下降且无法解决，和发现更加低估更加优秀的公司时会选择卖出股票。</p><h3 id="八，合理分散，适度集中"><a href="#八，合理分散，适度集中" class="headerlink" title="八，合理分散，适度集中"></a>八，合理分散，适度集中</h3><p>合理分散，再优秀的公司都可能遭遇黑天鹅，不应该全仓一只股票，应该合理分散，把资金投资于多家优秀且低估的公司。但不宜过度分散，因为优秀且低估的公司毕竟只是少数，不能为了分散而分散，去投资那些平庸或者高估的公司。</p><h3 id="九，韬光养晦，时来逆转"><a href="#九，韬光养晦，时来逆转" class="headerlink" title="九，韬光养晦，时来逆转"></a>九，韬光养晦，时来逆转</h3><p>真正投资的智者，不是要抓住每一次机会，而是静心等待一次完美的机会才出手。下跌的时候敢于低估买入优秀的公司，耐心等待，等待牛市到来，人性亘古不变，牛市总会到来，等待优秀的公司盈利的增长，等待市场给予优秀的公司更高的估值。选出优秀的公司，静静等待其股价极度低估的时候，重仓买入，耐心等待市场回暖，借助大势，耐心等待就是韬光养晦的精髓，耐心等待时来逆转。</p><h3 id="十，修心养性，道为我用"><a href="#十，修心养性，道为我用" class="headerlink" title="十，修心养性，道为我用"></a>十，修心养性，道为我用</h3><ul><li>夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远。</li><li>投资是一场没有尽头的修行，投资时间越长，收获的回报越大。</li><li>投资，养生，修心，三道合一。</li><li>佛法的全部就是（戒）除不良的恶念，（定）内心的平静，（慧）收获智慧，主动行动处理生活上的烦恼</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数月前有幸读了关善祥老师的《传世书》，感受颇多，撰一文以记之。&lt;/p&gt;
&lt;h3 id=&quot;传世家书&quot;&gt;&lt;a href=&quot;#传世家书&quot; class=&quot;headerlink&quot; title=&quot;传世家书&quot;&gt;&lt;/a&gt;传世家书&lt;/h3&gt;&lt;p&gt;贫穷就像传染病，传染了一代又一代人。通过投资的方式，家族财富以复利增长，以此为家风流传后世，为家族谋发展。日本有很多工匠家族，专注技艺，将工匠精神一直流传；投资也可以成为一种技艺，一种精神，一种思想流传给后代子孙，使家族事业长青。&lt;br&gt;
    
    </summary>
    
      <category term="EM" scheme="http://www.lizq.top/categories/EM/"/>
    
      <category term="价值投资" scheme="http://www.lizq.top/categories/EM/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="价值投资" scheme="http://www.lizq.top/tags/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84/"/>
    
      <category term="传世书" scheme="http://www.lizq.top/tags/%E4%BC%A0%E4%B8%96%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>大觉归真</title>
    <link href="http://www.lizq.top/2018/10/03/EM/%E5%BF%83%E6%80%81/%E5%A4%A7%E8%A7%89%E5%BD%92%E7%9C%9F/"/>
    <id>http://www.lizq.top/2018/10/03/EM/心态/大觉归真/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2019-04-14T14:31:53.979Z</updated>
    
    <content type="html"><![CDATA[<p>至高的顿悟就是归于真实。最近读了大觉归真一书，才发现佛学也可以如此地贴近现代社会，这大概也是佛学文化先进性的表现吧，不断吸收、更新、发展和丰富自身。书中讲到心的管理，财的管理，人的管理，其实是一种济时解困，责任务实的精神。现在的人们经常浸润在各种“美好的”的文化之中，但是大部分人的幸福感并不高，因为我们看到的，想象到的都被各类媒体包装的很好很美，但是真正在身边和我们有关的，正在接触到的却不是那样。欲而不得，事与愿违，正是这种落差造成了我们的痛苦。济时解困，责任务实也许是现在人们需要的良药。<br><a id="more"></a></p><h3 id="心的管理，就是生命的管理"><a href="#心的管理，就是生命的管理" class="headerlink" title="心的管理，就是生命的管理"></a>心的管理，就是生命的管理</h3><p>一个人，能管好自己的生命，管好自己的心，这是一种责任自觉，对自己负责。有了这种自觉，什么事情不能解决？心的管理就是提高心理免疫力，避免外界事物对人内心的压力。外物有太多不良病菌随时向我们袭来，这是不可避免的，我们只能增强自己的免疫力。人性就是外物的接收器，将外物转化为内心的压力，很多压力来自于攀比、贪婪、和困苦。当你看到人家有的东西你没有，你的贪婪之心就会被放大，所求不得，就会进入困境，导致痛苦。</p><p>要管理好自己的心，即修心，需要怎么做呢</p><ul><li>认知自我和外界环境，戒贪，人最大的误区，是认知的误区</li><li>诚心</li><li>信念</li><li>感恩</li><li>自律，人最宝贵的财富是自律，有一颗为别人着想的心，才能自律</li><li>遇到困难时，苦精进，勤精进</li></ul><h3 id="让外物给你带来幸福感"><a href="#让外物给你带来幸福感" class="headerlink" title="让外物给你带来幸福感"></a>让外物给你带来幸福感</h3><ul><li>很多时候帮助别人可以给你带来快乐和幸福，这是人内心去爱他人的诉求，我们需要唤醒我爱的能力</li><li>休息，也是缘，人是一个消耗、修养、补充、循环的过程</li><li>一个人的样子，是内在修养和素质的体现，求万事之容，不如免一事之辱；邀千人之欢，不如释一人之怒</li><li>知世知时，有品有德，做事有三种境界，下等做自己喜欢的事，中等做自己应该做的事，上等做上天让自己做的事；要能看破人之间因缘的聚散</li><li>立功，立言，立德</li><li>人不缺少学习，缺少的是体验</li><li>人是有意志和信念的，要控制自己的意志，让它给你创造幸福</li><li>真正的财富是你的内心，不论生老病死始终陪伴着你</li><li>真正的财富是长久的，永远能增值的</li></ul><p>以上读这本书的一些摘录和思考，有一句是人不缺少学习，缺少的是体验，信息爆炸的年代，随处随时都可以学习，但学习和学到相差太远，没有自己的思考和体验，永远学不到。生活还有很长很久，也许还会很美，知足，勤勉，珍惜！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至高的顿悟就是归于真实。最近读了大觉归真一书，才发现佛学也可以如此地贴近现代社会，这大概也是佛学文化先进性的表现吧，不断吸收、更新、发展和丰富自身。书中讲到心的管理，财的管理，人的管理，其实是一种济时解困，责任务实的精神。现在的人们经常浸润在各种“美好的”的文化之中，但是大部分人的幸福感并不高，因为我们看到的，想象到的都被各类媒体包装的很好很美，但是真正在身边和我们有关的，正在接触到的却不是那样。欲而不得，事与愿违，正是这种落差造成了我们的痛苦。济时解困，责任务实也许是现在人们需要的良药。&lt;br&gt;
    
    </summary>
    
      <category term="EM" scheme="http://www.lizq.top/categories/EM/"/>
    
      <category term="心态" scheme="http://www.lizq.top/categories/EM/%E5%BF%83%E6%80%81/"/>
    
    
      <category term="心态" scheme="http://www.lizq.top/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>App Logs in K8s Cluster</title>
    <link href="http://www.lizq.top/2018/09/12/CS/Kubernetes/elk/"/>
    <id>http://www.lizq.top/2018/09/12/CS/Kubernetes/elk/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.077Z</updated>
    
    <content type="html"><![CDATA[<p>近期实践了在k8s集群内对各个应用的日志处理，起因是开发那边反应服务器环境调试的时候查看日志特别麻烦，毕竟在开发本地毫无问题的代码在服务器上没有bug的概率还是比较低的。之前也有上elastic技术栈的计划，但是做得并没有那么完善。    </p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在k8s集群中，可以将日志简单得分为三类：节点级别日志、集群级别日志和运行在集群内的应用日志，这里仅仅实践了集群内的应用日志。<br>elastic技术栈的大致架构为： app —&gt; filebeat（fluenetd,logstash） —&gt; elasticsearch —&gt; kibana<br>在CICD流程中自动化部署的服务上线后，日志收集工具实时监听应用的日志信息，并将日志推送到elasticsearch，开发就可以在kibana上搜索到日志，考虑到logstash过于庞大，则用轻量级的filebeat替代     </p><a id="more"></a><p><img src="./k8s-app-log.png" alt="k8s-app-log"></p><p>一般说来，收集应用日志有以下三种做法：</p><ol><li>在集群中每个节点运行一个filebeat的pod，因为运行在节点上的容器会将控制台的标准输出保存在/var/lib/docker/containers目录下，因此只需将该目录以volume的形式挂载在日志收集组件的pod里</li><li>在每个应用的pod里加一个filebeat容器，用volume把应用容器里的日志文件共享到filebeat容器里</li><li>在每个应用的容器里加一个filebeat服务，直接本地读取日志文件</li></ol><p>第一种做法最简单便捷，实验下来发现读取到的日志有遗漏，而且有一些无关的日志，于是我采取的是第二种做法</p><h3 id="实验要点"><a href="#实验要点" class="headerlink" title="实验要点"></a>实验要点</h3><blockquote><p>制作filebeat的docker镜像<br><figure class="hljs highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /opt/filebeat</span></span><br><span class="line"><span class="bash">WORKDIR /opt/filebeat</span></span><br><span class="line"><span class="bash">RUN apt update -y &amp;&amp; apt install -y wget &amp;&amp; \  </span></span><br><span class="line"><span class="bash">  wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.4.0-linux-x86_64.tar.gz -O filebeat-6.4.0-linux-x86_64.tar.gz &amp;&amp; tar zxvf filebeat-6.4.0-linux-x86_64.tar.gz &amp;&amp; \  </span></span><br><span class="line"><span class="bash">  rm -rf filebeat-6.4.0-linux-x86_64.tar.gz &amp;&amp; \  </span></span><br><span class="line"><span class="bash">  apt-get purge -y wget &amp;&amp; \</span></span><br><span class="line"><span class="bash">  apt-get autoremove -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">  apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span></span><br><span class="line"><span class="bash">RUN mv ./filebeat-6.4.0-linux-x86_64/* ./ &amp;&amp; mv filebeat /usr/<span class="built_in">local</span>/bin/</span></span><br><span class="line"><span class="bash">COPY filebeat.yml /opt/filebeat/filebeat.yml</span></span><br><span class="line"><span class="bash">CMD filebeat</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>部署pod<br><figure class="hljs highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: test-logstash</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: egg-example</span><br><span class="line">    <span class="attribute">image</span>: <span class="number">10.28</span>.<span class="number">18.13</span>/xuntian/egg-example</span><br><span class="line">    <span class="attribute">imagePullPolicy</span>: IfNotPresent</span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">    - <span class="attribute">name</span>: app-logs</span><br><span class="line">      <span class="attribute">mountPath</span>: /root</span><br><span class="line">  - <span class="attribute">name</span>: filebeat</span><br><span class="line">    <span class="attribute">image</span>: <span class="number">10.28</span>.<span class="number">18.13</span>/xuntian/<span class="attribute">filebeat</span>:<span class="number">6.4</span></span><br><span class="line">    <span class="attribute">imagePullPolicy</span>: IfNotPresent</span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">    - <span class="attribute">name</span>: app-logs</span><br><span class="line">      <span class="attribute">mountPath</span>: /root</span><br><span class="line">  <span class="attribute">volumes</span>:</span><br><span class="line">  - <span class="attribute">name</span>: app-logs</span><br><span class="line">    <span class="attribute">emptyDir</span>: &#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>简单地用egg.js写了一些测试接口，打包成docker镜像，部署时加上filebeat的容器，监听egg-example项目的日志，最终可以看到egg-example项目的日志被完整地读取并写入es中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期实践了在k8s集群内对各个应用的日志处理，起因是开发那边反应服务器环境调试的时候查看日志特别麻烦，毕竟在开发本地毫无问题的代码在服务器上没有bug的概率还是比较低的。之前也有上elastic技术栈的计划，但是做得并没有那么完善。    &lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;在k8s集群中，可以将日志简单得分为三类：节点级别日志、集群级别日志和运行在集群内的应用日志，这里仅仅实践了集群内的应用日志。&lt;br&gt;elastic技术栈的大致架构为： app —&amp;gt; filebeat（fluenetd,logstash） —&amp;gt; elasticsearch —&amp;gt; kibana&lt;br&gt;在CICD流程中自动化部署的服务上线后，日志收集工具实时监听应用的日志信息，并将日志推送到elasticsearch，开发就可以在kibana上搜索到日志，考虑到logstash过于庞大，则用轻量级的filebeat替代     &lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="k8s" scheme="http://www.lizq.top/categories/CS/k8s/"/>
    
      <category term="log" scheme="http://www.lizq.top/categories/CS/k8s/log/"/>
    
    
      <category term="k8s" scheme="http://www.lizq.top/tags/k8s/"/>
    
      <category term="log" scheme="http://www.lizq.top/tags/log/"/>
    
      <category term="elk" scheme="http://www.lizq.top/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>关于黑苹果的一些建议</title>
    <link href="http://www.lizq.top/2018/08/05/CS/Hackintosh/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    <id>http://www.lizq.top/2018/08/05/CS/Hackintosh/黑苹果/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>作为一个程序员，怎么不对mac os x系统神往已久呢，于是在大学毕业能赚钱之后就立马买了一台Mac book pro，用了一段时间，感觉很好。对于一个运维来说，一个强大好用的终端胜过一切，对windows 10 我已经累觉不爱了，也不想总是在虚拟机里放ppt，于是在之前换上了ubuntu桌面版。老实说，ubuntu作为服务器操作系统确实强大，但是真的不适合最为工作机，一是缺少很多常用软件，二是桌面程序很不稳定，无奈之下走上了黑苹果的不归路。折腾黑苹果对我来说只是一种乐趣，虽说这浪费了我很多时间，甚至有点得不偿失了。<br><a id="more"></a></p><h2 id="想法和建议"><a href="#想法和建议" class="headerlink" title="想法和建议"></a>想法和建议</h2><h3 id="希望你是出于兴趣"><a href="#希望你是出于兴趣" class="headerlink" title="希望你是出于兴趣"></a>希望你是出于兴趣</h3><p>安装黑苹果是件很烦人的事情，尤其当你在一遍遍尝试各种配置文件的时候。如果你对这个东西没有兴趣，可能中途就会放弃了，我当初差点就放弃了；我当时是新买了一台台式机来折腾黑苹果的，也算是多少花了一点代价，如果不是兴趣的话，我应该也没那么舍得。</p><h3 id="建议在台式机上安装"><a href="#建议在台式机上安装" class="headerlink" title="建议在台式机上安装"></a>建议在台式机上安装</h3><p>所谓黑苹果就是在普通的pc上安装苹果的os x系统，前段时间已经更新到10.14了，但是全面普及还需要很长一段时间，我这里安装的10.13.1，注意安装黑苹果的系统版本很重要。在我的理解看来，安装黑苹果就是设置一系列的配置文件，设置虚假的硬件信息，以骗过苹果系统，认为它是安装在正常的Mac上，所以难免会有一些兼容性的驱动问题，主要体现在显卡，声卡和网卡上。我个人不是很建议在笔记本上安装黑苹果，因为这涉及的驱动很多，显卡声卡网卡，摄像头触摸板电源，真心浪费时间，当然喜欢折腾的可以尝试一下，或者找一些大神已经成功了的教程参考一下，这样会好一点，一般来说在台式机上安装黑苹果会容易很多。</p><h3 id="购买主流常见的硬件"><a href="#购买主流常见的硬件" class="headerlink" title="购买主流常见的硬件"></a>购买主流常见的硬件</h3><p>黑苹果最最关键的是各种各有的配置文件，这些配置文件大多是由一些国外大神开发编译好，发布到网上，然后由我们这些小白拿过来，修修补补拼拼凑凑，运气好的话说不定就有用了，大神毕竟是少数且精力有限，不可能对所有的硬件进行适配，所以购买主流硬件是为了方便找到管用的配置，这也是比较重要的。一般来说，CPU最好是Intel的，毕竟成功的案例更多；主板最好是技嘉的，微星和华硕的也可以考虑；我的建议是去掉独显，用Intel的核显就够用了，如果非要独显的话，英伟达和amd都可以，看你怎么驱动了；尽量用有线网卡，Wi-Fi的话，很多无线网卡的驱动是无解的；一定要有固态硬盘，os x 系统的磁盘系统不是很好，没有固态硬盘的话，体验是很不友好的；键盘和鼠标随意，普通的键盘鼠标均可以适配；显示器有条件的话，可以买好一点的，4K显示器开启hidpi效果很棒。</p><h3 id="有耐心，懂英文"><a href="#有耐心，懂英文" class="headerlink" title="有耐心，懂英文"></a>有耐心，懂英文</h3><p>如果说安装黑苹果算是一门技术活的话，最大的缺陷就是教程和论坛比较少了；不像编程语言等其他计算机技术基本都有很多的网络社区，教程和文档；国内能够稍微有点用的就只有远景论坛了，其他的基本没什么参考作用，国外的话到是有不少，具体的可以Google一下，YouTube上也有很多相关的视频可以参考，外国很多技术人员还是很有探索精神的，对很多部分的原理都解释得很详细。如果不懂英文的话，可以会比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;由来&quot;&gt;&lt;a href=&quot;#由来&quot; class=&quot;headerlink&quot; title=&quot;由来&quot;&gt;&lt;/a&gt;由来&lt;/h2&gt;&lt;p&gt;作为一个程序员，怎么不对mac os x系统神往已久呢，于是在大学毕业能赚钱之后就立马买了一台Mac book pro，用了一段时间，感觉很好。对于一个运维来说，一个强大好用的终端胜过一切，对windows 10 我已经累觉不爱了，也不想总是在虚拟机里放ppt，于是在之前换上了ubuntu桌面版。老实说，ubuntu作为服务器操作系统确实强大，但是真的不适合最为工作机，一是缺少很多常用软件，二是桌面程序很不稳定，无奈之下走上了黑苹果的不归路。折腾黑苹果对我来说只是一种乐趣，虽说这浪费了我很多时间，甚至有点得不偿失了。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="hackintosh" scheme="http://www.lizq.top/categories/CS/hackintosh/"/>
    
    
      <category term="hackintosh" scheme="http://www.lizq.top/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>超额收益</title>
    <link href="http://www.lizq.top/2018/07/11/EM/%E6%8A%95%E8%B5%84/%E8%B6%85%E9%A2%9D%E6%94%B6%E7%9B%8A/"/>
    <id>http://www.lizq.top/2018/07/11/EM/投资/超额收益/</id>
    <published>2018-07-10T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.083Z</updated>
    
    <content type="html"><![CDATA[<p>此书可作为价值投资的入门书籍，作者为刘哲。    </p><p>这是最坏的时代，这也是最好的时代；这是愚蠢的时代，这也是智慧的时代；这是怀疑的时期，这也是信仰的时期；这是黑暗的季节，这也是光明的季节；这是失望之冬，这也是希望之春；人们面前应有尽有，人们面前一无所有；人们正在踏上天堂之路，人们正走向地狱之门。</p><p>———狄更斯的《双城记》</p><a id="more"></a><h2 id="为什么要投资"><a href="#为什么要投资" class="headerlink" title="为什么要投资"></a>为什么要投资</h2><ul><li>现金不是资产，投资可以使资产保值、增值</li><li>保证充足的现金流</li><li>实现财富自由</li><li>对于普通人来说，可以投资的标的有限，优秀公司的股票、业绩良好的基金、核心城市好地段的房产等</li></ul><h2 id="价值投资"><a href="#价值投资" class="headerlink" title="价值投资"></a>价值投资</h2><ul><li>能够稳定盈利的投资方式，价值投资和指数投资</li><li>价值投资就是从市场的错误定价中获利</li><li>长期来看，股票价格必定向价值回归</li><li>投资只需要学好两门课，一是如何给企业定价，二是如何看待股市的波动</li><li>赚钱方式有很多种，只赚自己能看懂和能把握的钱</li><li>好行业，好公司，好价格，寻找有增长潜力的行业，在该行业中找出最具竞争优势的公司，等待该公司的股价低估的时候买入</li><li>某几天的行情可能决定了一年大部分的收益，就是说，闪电打下来的时候你必须在场，择时非常困难</li></ul><h2 id="价值投资的难点"><a href="#价值投资的难点" class="headerlink" title="价值投资的难点"></a>价值投资的难点</h2><ul><li>投资者自身认识和能力有限，收集到的信息和评估方法有限，不能客观地评估公司，对公司价值认识错误</li><li>世界变化太快，企业发展出乎意料</li><li>无法控制自身情绪和人性弱点</li></ul><h2 id="宏观经济"><a href="#宏观经济" class="headerlink" title="宏观经济"></a>宏观经济</h2><ul><li>宏观经济对股市不重要</li><li>宏观经济过于复杂，各种影响因素互相关联，彼此影响，且有太多人为（政府）干预</li><li>股市通常是经济的先行指标，宏观经济和股市并没有必然联系</li><li>经济增长潜力和重要，国家的发展趋势很重要，即国运</li><li>宏观经济对周期股影响很大  </li></ul><h2 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h2><ul><li>行业就是需求的分类，需求不断增长的行业才有发展的动力</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此书可作为价值投资的入门书籍，作者为刘哲。    &lt;/p&gt;
&lt;p&gt;这是最坏的时代，这也是最好的时代；这是愚蠢的时代，这也是智慧的时代；这是怀疑的时期，这也是信仰的时期；这是黑暗的季节，这也是光明的季节；这是失望之冬，这也是希望之春；人们面前应有尽有，人们面前一无所有；人们正在踏上天堂之路，人们正走向地狱之门。&lt;/p&gt;
&lt;p&gt;———狄更斯的《双城记》&lt;/p&gt;
    
    </summary>
    
      <category term="EM" scheme="http://www.lizq.top/categories/EM/"/>
    
      <category term="价值投资" scheme="http://www.lizq.top/categories/EM/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="价值投资" scheme="http://www.lizq.top/tags/%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>Cmake</title>
    <link href="http://www.lizq.top/2018/04/11/CS/C/cmake/"/>
    <id>http://www.lizq.top/2018/04/11/CS/C/cmake/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的应用实例"><a href="#简单的应用实例" class="headerlink" title="简单的应用实例"></a>简单的应用实例</h2><p>main.c文件内容<br><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建CMakeList.txt文件<br><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROJECT (HELLO)</span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.c)</span></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">"This is BINARY dir "</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">"This is SOURCE dir "</span> $&#123;HELLO_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>开始构建 cmake .<br><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">所有的文件创建完成后，t1 目录中应该存在main.c和 CMakeLists.txt 两个文件</span><br><span class="line">接下来我们来构建这个工程，在这个目录运行：</span><br><span class="line">cmake . (注意命令后面的点号，代表本目录)。</span><br><span class="line">输出大概是这个样子：</span><br><span class="line">-<span class="ruby">- Check <span class="keyword">for</span> working C <span class="symbol">compiler:</span> /usr/bin/gcc</span></span><br><span class="line"><span class="ruby">-- Check <span class="keyword">for</span> working C <span class="symbol">compiler:</span> /usr/bin/gcc -- works</span></span><br><span class="line"><span class="ruby">-- Check size of void*</span></span><br><span class="line"><span class="ruby">-- Check size of void* - done</span></span><br><span class="line"><span class="ruby">-- Check <span class="keyword">for</span> working CXX <span class="symbol">compiler:</span> /usr/bin/c++</span></span><br><span class="line"><span class="ruby">-- Check <span class="keyword">for</span> working CXX <span class="symbol">compiler:</span> /usr/bin/c++ -- works</span></span><br><span class="line"><span class="ruby">-- This is BINARY dir /backup/cmake/t1</span></span><br><span class="line"><span class="ruby">-- This is SOURCE dir /backup/cmake/t1</span></span><br><span class="line"><span class="ruby">-- Configuring done</span></span><br><span class="line"><span class="ruby">-- Generating done</span></span><br><span class="line"><span class="ruby">-- Build files have been written <span class="symbol">to:</span> /backup/cmake/t1</span></span><br><span class="line"><span class="ruby">再让我们看一下目录中的内容：</span></span><br><span class="line"><span class="ruby">你会发现，系统自动生成了：</span></span><br><span class="line"><span class="ruby">CMakeFiles, CMakeCache.txt, cmake_install.cmake等文件，并且生成了Makefile.</span></span><br><span class="line"><span class="ruby">现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">然后进行工程的实际构建，在这个目录输入 make命令，大概会得到如下的彩色输出：</span></span><br><span class="line"><span class="ruby">Scanning dependencies of target hello</span></span><br><span class="line"><span class="ruby">[<span class="number">100</span>%] Building C object CMakeFiles/hello.dir/main.o</span></span><br><span class="line"><span class="ruby">Linking C executable hello</span></span><br><span class="line"><span class="ruby">[<span class="number">100</span>%] Built target hello</span></span><br><span class="line"><span class="ruby">如果你需要看到make构建的详细过程，可以使用make VERBOSE=<span class="number">1</span> 或者VERBOSE=<span class="number">1</span></span></span><br><span class="line"><span class="ruby">make命令来进行构建。</span></span><br><span class="line"><span class="ruby">这时候，我们需要的目标文件hello 已经构建完成，位于当前目录，尝试运行一下：</span></span><br><span class="line"><span class="ruby">./hello</span></span><br><span class="line"><span class="ruby">得到输出：</span></span><br><span class="line"><span class="ruby">Hello World from Main</span></span><br></pre></td></tr></table></figure></p><h2 id="对实例的解释"><a href="#对实例的解释" class="headerlink" title="对实例的解释"></a>对实例的解释</h2><p>PROJECT指令的语法是<br><code>PROJECT(projectname [CXX] [C] [Java])</code><br>SET指令的语法是<br><code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><br>现阶段，你只需要了解SET指令可以用来显式的定义变量即可。<br>比如我们用到的是SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：<br><code>SET(SRC_LIST main.c t1.c t2.c)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的应用实例&quot;&gt;&lt;a href=&quot;#简单的应用实例&quot; class=&quot;headerlink&quot; title=&quot;简单的应用实例&quot;&gt;&lt;/a&gt;简单的应用实例&lt;/h2&gt;&lt;p&gt;main.c文件内容&lt;br&gt;&lt;figure class=&quot;hljs highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;新建CMakeList.txt文件&lt;br&gt;&lt;figure class=&quot;hljs highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PROJECT (HELLO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;SET&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SRC_LIST main.c)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;MESSAGE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(STATUS &lt;span class=&quot;string&quot;&gt;&quot;This is BINARY dir &quot;&lt;/span&gt; $&amp;#123;HELLO_BINARY_DIR&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;MESSAGE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(STATUS &lt;span class=&quot;string&quot;&gt;&quot;This is SOURCE dir &quot;&lt;/span&gt; $&amp;#123;HELLO_SOURCE_DIR&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;ADD_EXECUTABLE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(hello $&amp;#123;SRC_LIST&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="c语言" scheme="http://www.lizq.top/categories/CS/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="cmake" scheme="http://www.lizq.top/categories/CS/c%E8%AF%AD%E8%A8%80/cmake/"/>
    
    
      <category term="cmake" scheme="http://www.lizq.top/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Gcc</title>
    <link href="http://www.lizq.top/2018/03/31/CS/C/gcc/"/>
    <id>http://www.lizq.top/2018/03/31/CS/C/gcc/</id>
    <published>2018-03-30T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gcc命令常用选项及工作流程"><a href="#gcc命令常用选项及工作流程" class="headerlink" title="gcc命令常用选项及工作流程"></a>gcc命令常用选项及工作流程</h2><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">c      <span class="comment"># 对源文件进行编译或汇编</span></span></span><br><span class="line"><span class="ruby">-E      <span class="comment"># 对源文件进行预处理</span></span></span><br><span class="line"><span class="ruby">-S      <span class="comment"># 对源文件进行编译</span></span></span><br><span class="line"><span class="ruby">-o file <span class="comment"># 输出目标文件file</span></span></span><br><span class="line"><span class="ruby">-v      <span class="comment"># 显示编译阶段命令</span></span></span><br></pre></td></tr></table></figure><p>新建文件 vim test.c<br><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>预处理 gcc -E test.c -o test.i, 这时可以看到多了test.i文件, 查看test.i文件的内容，可以看到stdio.h的内容被加在了前面</p><p>编译 gcc -S test.i -o test.s, 编译生成了新的文件test.s, 查看test.s文件的内容可以看到其内容为汇编代码</p><p>汇编 gcc -c test.s -o test.o, 该命令会生成名为test.o的目标文件, 在windows下目标文件的后缀名是obj, test.o文件是二进制文件, 但是无法运行</p><p>链接 gcc test.o -o test, 改步骤会把test.o文件和函数库文件链接在一起, 生成新的可执行二进制文件test, 执行该文件即可打印出hello world</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./<span class="built_in">test</span></span></span><br><span class="line">hello world.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gcc命令常用选项及工作流程&quot;&gt;&lt;a href=&quot;#gcc命令常用选项及工作流程&quot; class=&quot;headerlink&quot; title=&quot;gcc命令常用选项及工作流程&quot;&gt;&lt;/a&gt;gcc命令常用选项及工作流程&lt;/h2&gt;&lt;figure class=&quot;hljs highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;c      &lt;span class=&quot;comment&quot;&gt;# 对源文件进行编译或汇编&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-E      &lt;span class=&quot;comment&quot;&gt;# 对源文件进行预处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-S      &lt;span class=&quot;comment&quot;&gt;# 对源文件进行编译&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-o file &lt;span class=&quot;comment&quot;&gt;# 输出目标文件file&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-v      &lt;span class=&quot;comment&quot;&gt;# 显示编译阶段命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新建文件 vim test.c&lt;br&gt;&lt;figure class=&quot;hljs highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello world.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="c语言" scheme="http://www.lizq.top/categories/CS/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="gcc" scheme="http://www.lizq.top/categories/CS/c%E8%AF%AD%E8%A8%80/gcc/"/>
    
    
      <category term="gcc" scheme="http://www.lizq.top/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>Shell</title>
    <link href="http://www.lizq.top/2018/01/18/CS/Linux/shell/"/>
    <id>http://www.lizq.top/2018/01/18/CS/Linux/shell/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.079Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux操作系统通过kernel(内核)控制底层硬件，如内存管理、进程调度、鼠标键盘的驱动等，但是用户无法通过kernel对计算机进行控制，而是通过shell与kernel通信，达到控制计算机的目的</li><li>Shell分为两种，CLI和GUI</li></ul><h2 id="Shell命令行"><a href="#Shell命令行" class="headerlink" title="Shell命令行"></a>Shell命令行</h2><h3 id="Linux下bash快捷键"><a href="#Linux下bash快捷键" class="headerlink" title="Linux下bash快捷键"></a>Linux下bash快捷键</h3><ul><li>Ctrl+A: 切换到命令行开始</li><li>Ctrl+E: 切换到命令行末尾</li><li>Ctrl+L: 清屏，相当于clear</li><li>Ctrl+U: 清除剪切光标之前的内容</li><li>Ctrl+K: 清除剪切光标之后的内容</li><li>Ctrl+Y: 粘贴刚才删除的字符</li><li>Ctrl+R: 在历史命令中查找</li><li>Ctrl+C: 终止命令</li><li>Ctrl+D: 退出当前终端</li><li>Ctrl+Z: 转入后台运行</li><li>!!:     重复执行上一条命令</li><li>!$:     显示系统最近的一条参数</li><li>history 系统命令历史，不只是当前终端的命令历史，而是整个系统的</li><li>!字符 重复执行之前最近一个以该字符开头的命令</li><li>!数字 按照历史记录的序号执行命令</li><li>!?abc 重复执行之前包含abc的命令</li><li>!-n   重复执行n个命令之前的那个命令</li><li>esc + . 重复调用上一个命令的参数，但不重复执行上一个命令<a id="more"></a></li></ul><h3 id="命令行通配符"><a href="#命令行通配符" class="headerlink" title="命令行通配符"></a>命令行通配符</h3><ul><li>* 匹配0个或多个字符</li><li>？ 匹配任意一个字符</li><li>[0-9] 匹配一个数字范围</li><li>[abc]  匹配列表里的任意字符</li><li>[^abc] 匹配列表以外的字符</li></ul><h3 id="Linux-shell-commands"><a href="#Linux-shell-commands" class="headerlink" title="Linux shell commands"></a>Linux shell commands</h3><ul><li>id 返回当前用户信息</li><li>passwd 修改当前用户密码</li><li>su 切换到root用户，但不开启新的终端，仍在之前的目录下，su - 切换到root用户，并切换目录到root根目录/root</li></ul><h3 id="bash-作业管理"><a href="#bash-作业管理" class="headerlink" title="bash 作业管理"></a>bash 作业管理</h3><ul><li>在命令后加一个&amp;符号将命令放在后台运行</li><li>jobs 查看当前在后台运行的所有作业</li><li>bg 让程序在后台继续运行</li><li>fg 将程序放到前台执行</li></ul><h3 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：<br>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。<br>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。<br>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。<br><figure class="hljs highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 如果希望 stderr 重定向到 <span class="keyword">file</span>，可以这样写：</span><br><span class="line">$ <span class="keyword">command</span> <span class="number">2</span> &gt; <span class="keyword">file</span></span><br><span class="line"># 如果希望 stderr 追加到 <span class="keyword">file</span> 文件末尾，可以这样写：</span><br><span class="line">$ <span class="keyword">command</span> <span class="number">2</span> &gt;&gt; <span class="keyword">file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">command</span> &gt; <span class="keyword">file</span>将输出重定向到 <span class="keyword">file</span>。</span><br><span class="line"><span class="keyword">command</span> &lt; <span class="keyword">file</span>将输入重定向到 <span class="keyword">file</span>。</span><br><span class="line"><span class="keyword">command</span> &gt;&gt; <span class="keyword">file</span>将输出以追加的方式重定向到 <span class="keyword">file</span>。</span><br><span class="line">n &gt; <span class="keyword">file</span>将文件描述符为 n 的文件重定向到 <span class="keyword">file</span>。</span><br><span class="line">n &gt;&gt; <span class="keyword">file</span>将文件描述符为 n 的文件以追加的方式重定向到 <span class="keyword">file</span>。</span><br><span class="line">n &gt;&amp; <span class="keyword">m</span>将输出文件 <span class="keyword">m</span> 和 n 合并。</span><br><span class="line">n &lt;&amp; <span class="keyword">m</span>将输入文件 <span class="keyword">m</span> 和 n 合并。</span><br><span class="line">&lt;&lt; <span class="keyword">tag</span>将开始标记 <span class="keyword">tag</span> 和结束标记 <span class="keyword">tag</span> 之间的内容作为输入。</span><br><span class="line"></span><br><span class="line"># 如果希望将 stdout 和 stderr 合并后重定向到 <span class="keyword">file</span>，可以这样写：</span><br><span class="line">$ <span class="keyword">command</span> &gt; <span class="keyword">file</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">或者</span><br><span class="line">$ <span class="keyword">command</span> &gt;&gt; <span class="keyword">file</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"># 如果希望对 stdin 和 stdout 都重定向，可以这样写：</span><br><span class="line">$ <span class="keyword">command</span> &lt; file1 &gt;file2</span><br><span class="line"><span class="keyword">command</span> 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</span><br></pre></td></tr></table></figure></p><ul><li>/dev/null 文件<br>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：<figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null</span></span><br></pre></td></tr></table></figure></li></ul><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。<br>如果希望屏蔽 stdout 和 stderr，可以这样写：<br><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure></p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><ul><li>只读变量 readonly   </li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">"http://www.w3cschool.cc"</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">"http://www.runoob.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">/bin/sh: NAME: This variable is <span class="built_in">read</span> only.</span><br></pre></td></tr></table></figure><ul><li>删除变量 unset</li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><h3 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h3><ul><li>字符串可以用单引号，也可以用双引号，也可以不用引号</li><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的，单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li><li>双引号里可以有变量，双引号里可以出现转义字符</li><li><p>获取字符串的长度</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出 4</span></span><br></pre></td></tr></table></figure></li><li><p>提取子字符串</p><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>=<span class="string">"runoob is a great site"</span></span><br><span class="line">echo $&#123;<span class="built_in">string</span>:<span class="number">1</span>:<span class="number">4</span>&#125; <span class="comment"># 输出 unoo</span></span><br></pre></td></tr></table></figure></li><li><p>查找子字符串</p><figure class="hljs highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>=<span class="string">"runoob is a great company"</span></span><br><span class="line">echo `<span class="built_in">expr</span> index <span class="string">"$string"</span> <span class="keyword">is</span>`   <span class="comment"># 输出 8</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h3><ul><li><p>定义数组</p><figure class="hljs highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array<span class="number">_n</span>ame=(<span class="keyword">value</span><span class="number">0</span> <span class="keyword">value</span><span class="number">1</span> <span class="keyword">value</span><span class="number">2</span> <span class="keyword">value</span><span class="number">3</span>)</span><br><span class="line">array<span class="number">_n</span>ame=(</span><br><span class="line"><span class="keyword">value</span><span class="number">0</span></span><br><span class="line"><span class="keyword">value</span><span class="number">1</span></span><br><span class="line"><span class="keyword">value</span><span class="number">2</span></span><br><span class="line"><span class="keyword">value</span><span class="number">3</span></span><br><span class="line">)</span><br><span class="line">array<span class="number">_n</span>ame[<span class="number">0</span>]=<span class="keyword">value</span><span class="number">0</span></span><br><span class="line">array<span class="number">_n</span>ame[<span class="number">1</span>]=<span class="keyword">value</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>读取数组</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据下标获取数组元素</span></span><br><span class="line">valuen=<span class="variable">$&#123;array_name[n]&#125;</span></span><br><span class="line"><span class="comment"># 使用@符号可以获取数组中的所有元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>获取数组的长度</p><figure class="hljs highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line"><span class="attr">length</span>=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="attr">length</span>=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line"><span class="attr">lengthn</span>=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shell传递参数"><a href="#Shell传递参数" class="headerlink" title="Shell传递参数"></a>Shell传递参数</h3><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#传递到脚本的参数个数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">*以一个单字符串显示所有向脚本传递的参数。如<span class="string">"$*"</span>用「<span class="string">"」括起来的情况、以"</span><span class="variable">$1</span> <span class="variable">$2</span> … <span class="variable">$n</span><span class="string">"的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">$脚本运行的当前进程ID号</span></span><br><span class="line"><span class="meta">$</span><span class="bash">!后台运行的最后一个进程的ID号</span></span><br><span class="line"><span class="meta">$</span><span class="bash">@与$*相同，但是使用时加引号，并在引号中返回每个参数。如<span class="string">"<span class="variable">$@</span>"</span>用「<span class="string">"」括起来的情况、以"</span><span class="variable">$1</span><span class="string">" "</span><span class="variable">$2</span><span class="string">" … "</span><span class="variable">$n</span><span class="string">" 的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">-显示Shell使用的当前选项，与<span class="built_in">set</span>命令功能相同。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">?显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span></span><br></pre></td></tr></table></figure><h3 id="Shell基本运算符"><a href="#Shell基本运算符" class="headerlink" title="Shell基本运算符"></a>Shell基本运算符</h3><p>Shell支持多种运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符、文件测试运算符。原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用  </p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><figure class="hljs highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+加法<span class="string">`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</span>    </span><br><span class="line">-减法<span class="string">`expr <span class="variable">$a</span> - <span class="variable">$b</span>`</span>     </span><br><span class="line">*乘法<span class="string">`expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</span>     </span><br><span class="line">/除法<span class="string">`expr <span class="variable">$b</span> / <span class="variable">$a</span>`</span>    </span><br><span class="line">%取余<span class="string">`expr <span class="variable">$b</span> % <span class="variable">$a</span>`</span>     </span><br><span class="line">=赋值a=<span class="variable">$b</span> 将把变量 b 的值赋给 a。      </span><br><span class="line">==相等  用于比较两个数字，相同则返回 <span class="literal">true</span>。[ <span class="variable">$a</span> == <span class="variable">$b</span> ] 返回 <span class="literal">false</span>    </span><br><span class="line">!=不相等  用于比较两个数字，不相同则返回 <span class="literal">true</span>。[ <span class="variable">$a</span> != <span class="variable">$b</span> ] 返回 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>1.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样<br>2.完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号<br>3.乘号(*)前边必须加反斜杠()才能实现乘法运算   </p><ul><li>关系运算符</li></ul><p>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ]<br>-ne    检测两个数是否相等，不相等返回 true。    [ $a -ne $b ]<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ]<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ]<br>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ]<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ]     </p><ul><li>布尔运算符</li></ul><p>a=10<br>b=20<br>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。<br>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。<br>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。          </p><ul><li>逻辑运算符</li></ul><p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false<br>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true             </p><ul><li>字符串运算符</li></ul><p>=    检测两个字符串是否相等，相等返回 true。    [ $a = $b ] 返回 false。<br>!=    检测两个字符串是否相等，不相等返回 true。    [ $a != $b ] 返回 true。<br>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。<br>-n    检测字符串长度是否为0，不为0返回 true。    [ -n $a ] 返回 true。<br>str    检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。            </p><ul><li>文件测试运算符</li></ul><p>-b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ] 返回 false。<br>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。<br>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。<br>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。          </p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Linux操作系统通过kernel(内核)控制底层硬件，如内存管理、进程调度、鼠标键盘的驱动等，但是用户无法通过kernel对计算机进行控制，而是通过shell与kernel通信，达到控制计算机的目的&lt;/li&gt;
&lt;li&gt;Shell分为两种，CLI和GUI&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Shell命令行&quot;&gt;&lt;a href=&quot;#Shell命令行&quot; class=&quot;headerlink&quot; title=&quot;Shell命令行&quot;&gt;&lt;/a&gt;Shell命令行&lt;/h2&gt;&lt;h3 id=&quot;Linux下bash快捷键&quot;&gt;&lt;a href=&quot;#Linux下bash快捷键&quot; class=&quot;headerlink&quot; title=&quot;Linux下bash快捷键&quot;&gt;&lt;/a&gt;Linux下bash快捷键&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Ctrl+A: 切换到命令行开始&lt;/li&gt;
&lt;li&gt;Ctrl+E: 切换到命令行末尾&lt;/li&gt;
&lt;li&gt;Ctrl+L: 清屏，相当于clear&lt;/li&gt;
&lt;li&gt;Ctrl+U: 清除剪切光标之前的内容&lt;/li&gt;
&lt;li&gt;Ctrl+K: 清除剪切光标之后的内容&lt;/li&gt;
&lt;li&gt;Ctrl+Y: 粘贴刚才删除的字符&lt;/li&gt;
&lt;li&gt;Ctrl+R: 在历史命令中查找&lt;/li&gt;
&lt;li&gt;Ctrl+C: 终止命令&lt;/li&gt;
&lt;li&gt;Ctrl+D: 退出当前终端&lt;/li&gt;
&lt;li&gt;Ctrl+Z: 转入后台运行&lt;/li&gt;
&lt;li&gt;!!:     重复执行上一条命令&lt;/li&gt;
&lt;li&gt;!$:     显示系统最近的一条参数&lt;/li&gt;
&lt;li&gt;history 系统命令历史，不只是当前终端的命令历史，而是整个系统的&lt;/li&gt;
&lt;li&gt;!字符 重复执行之前最近一个以该字符开头的命令&lt;/li&gt;
&lt;li&gt;!数字 按照历史记录的序号执行命令&lt;/li&gt;
&lt;li&gt;!?abc 重复执行之前包含abc的命令&lt;/li&gt;
&lt;li&gt;!-n   重复执行n个命令之前的那个命令&lt;/li&gt;
&lt;li&gt;esc + . 重复调用上一个命令的参数，但不重复执行上一个命令
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
      <category term="shell" scheme="http://www.lizq.top/categories/CS/linux/shell/"/>
    
    
      <category term="shell" scheme="http://www.lizq.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Apt</title>
    <link href="http://www.lizq.top/2018/01/18/CS/Linux/apt/"/>
    <id>http://www.lizq.top/2018/01/18/CS/Linux/apt/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="apt-命令"><a href="#apt-命令" class="headerlink" title="apt 命令"></a>apt 命令</h2><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update  更新源</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package 安装包</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package --reinstall  重新安装包</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> -f install  修复安装</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-<span class="builtin-name">get</span><span class="built_in"> upgrade </span>更新已安装的包</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> source package  下载该包的源代码</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> clean &amp;&amp; sudo apt-<span class="builtin-name">get</span> autoclean 清理无用的包</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;apt-命令&quot;&gt;&lt;a href=&quot;#apt-命令&quot; class=&quot;headerlink&quot; title=&quot;apt 命令&quot;&gt;&lt;/a&gt;apt 命令&lt;/h2&gt;&lt;figure class=&quot;hljs highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; update  更新源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; install package 安装包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;builtin-name&quot;&gt;remove&lt;/span&gt; package 删除包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-cache search package 搜索软件包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; install package --reinstall  重新安装包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; -f install  修复安装&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;builtin-name&quot;&gt;remove&lt;/span&gt; package --purge 删除包，包括配置文件等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; build-dep package 安装相关的编译环境&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;built_in&quot;&gt; upgrade &lt;/span&gt;更新已安装的包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; dist-upgrade 升级系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-cache depends package 了解使用该包依赖那些包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-cache rdepends package 查看该包被哪些包依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; source package  下载该包的源代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; clean &amp;amp;&amp;amp; sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; autoclean 清理无用的包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; check 检查是否有损坏的依赖&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
    
      <category term="apt" scheme="http://www.lizq.top/tags/apt/"/>
    
  </entry>
  
  <entry>
    <title>磁盘管理</title>
    <link href="http://www.lizq.top/2018/01/04/CS/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.lizq.top/2018/01/04/CS/Linux/磁盘管理/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a或--all：包含全部的文件系统；</span></span><br><span class="line"><span class="ruby">--block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目；</span></span><br><span class="line"><span class="ruby">-h或--human-readable：以可读性较高的方式来显示信息；</span></span><br><span class="line"><span class="ruby">-H或--si：与-h参数相同，但在计算时是以<span class="number">1000</span> Bytes为换算单位而非<span class="number">1024</span> Bytes；</span></span><br><span class="line"><span class="ruby">-i或--inodes：显示inode的信息；</span></span><br><span class="line"><span class="ruby">-k或--kilobytes：指定区块大小为<span class="number">1024</span>字节；</span></span><br><span class="line"><span class="ruby">-l或--local：仅显示本地端的文件系统；</span></span><br><span class="line"><span class="ruby">-m或--megabytes：指定区块大小为<span class="number">1048576</span>字节；</span></span><br><span class="line"><span class="ruby">--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；</span></span><br><span class="line"><span class="ruby">-P或--portability：使用POSIX的输出格式；</span></span><br><span class="line"><span class="ruby">--sync：在取得磁盘使用信息前，先执行sync指令；</span></span><br><span class="line"><span class="ruby">-t&lt;文件系统类型&gt;或--type=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；</span></span><br><span class="line"><span class="ruby">-T或--print-type：显示文件系统的类型；</span></span><br><span class="line"><span class="ruby">-x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；</span></span><br><span class="line"><span class="ruby">--help：显示帮助；</span></span><br><span class="line"><span class="ruby">--version：显示版本信息。</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h2><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a或-all 显示目录中个别文件的大小。</span></span><br><span class="line"><span class="ruby">-b或-bytes 显示目录或文件大小时，以byte为单位。</span></span><br><span class="line"><span class="ruby">-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</span></span><br><span class="line"><span class="ruby">-k或--kilobytes 以KB(<span class="number">1024</span>bytes)为单位输出。</span></span><br><span class="line"><span class="ruby">-m或--megabytes 以MB为单位输出。</span></span><br><span class="line"><span class="ruby">-s或--summarize 仅显示总计，只列出最后加总的值。</span></span><br><span class="line"><span class="ruby">-h或--human-readable 以K，M，G为单位，提高信息的可读性。</span></span><br><span class="line"><span class="ruby">-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</span></span><br><span class="line"><span class="ruby">-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。</span></span><br><span class="line"><span class="ruby">-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</span></span><br><span class="line"><span class="ruby">-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</span></span><br><span class="line"><span class="ruby">--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</span></span><br><span class="line"><span class="ruby">-D或--dereference-args 显示指定符号链接的源文件大小。</span></span><br><span class="line"><span class="ruby">-H或--si 与-h参数相同，但是K，M，G是以<span class="number">1000</span>为换算单位。</span></span><br><span class="line"><span class="ruby">-l或--count-links 重复计算硬件链接的文件。</span></span><br></pre></td></tr></table></figure><figure class="hljs highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#显示当前目录下文件的大小，-d <span class="number">1</span>为指定检索深度depth=<span class="number">1</span></span><br><span class="line">du -h -d <span class="number">1</span> ./</span><br></pre></td></tr></table></figure><h2 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h2><p>fdisk命令用于观察硬盘实体使用情况，和对硬盘分区<br><figure class="hljs highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#参数</span><br><span class="line">-b&lt;分区大小&gt;：指定每个分区的大小；</span><br><span class="line">-l：列出指定的外围设备的分区表状况；</span><br><span class="line">-s&lt;分区编号&gt;：将指定的分区大小输出到标准输出上，单位为区块；</span><br><span class="line">-u：搭配<span class="string">"-l"</span>参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址；</span><br><span class="line">-v：显示版本信息。</span><br><span class="line"></span><br><span class="line"># fdisk /dev/sdb</span><br><span class="line">command (m <span class="keyword">for</span> help): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   <span class="built_in">delete</span> a <span class="built_in">partition</span></span><br><span class="line">   l   list known <span class="built_in">partition</span> types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a <span class="built_in">new</span> <span class="built_in">partition</span></span><br><span class="line">   o   create a <span class="built_in">new</span> empty DOS <span class="built_in">partition</span> table</span><br><span class="line">   p   <span class="built_in">print</span> the <span class="built_in">partition</span> table</span><br><span class="line">   q   <span class="built_in">quit</span> without <span class="built_in">saving</span> changes</span><br><span class="line">   s   create a <span class="built_in">new</span> empty Sun disklabel</span><br><span class="line">   t   change a <span class="built_in">partition</span>'s <span class="built_in">system</span> id</span><br><span class="line">   u   change <span class="built_in">display</span>/entry <span class="built_in">units</span></span><br><span class="line">   v   verify the <span class="built_in">partition</span> table</span><br><span class="line">   w   write table to disk <span class="keyword">and</span> exit</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure></p><h2 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h2><p>parted命令是由GNU组织开发的一款功能强大的磁盘分区和分区大小调整工具，与fdisk不同，它支持调整分区的大小。作为一种设计用于Linux的工具，它没有构建成处理与fdisk关联的多种分区类型，但是，它可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS以及Linux交换分区。<br><figure class="hljs highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-h：显示帮助信息；</span><br><span class="line">-i：交互式模式；</span><br><span class="line">-s：脚本模式，不提示用户；</span><br><span class="line">-v：显示版本号。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# parted <span class="regexp">/dev/</span>sdb</span><br><span class="line">GNU Parted Copyright (C) <span class="number">1998</span> - <span class="number">2004</span> free Software Foundation, Inc.</span><br><span class="line"><span class="keyword">This</span> program is free software, covered by the GNU General <span class="keyword">Public</span> License.</span><br><span class="line"><span class="keyword">This</span> program is distributed in the hope that it will be useful, but WITHOUT <span class="keyword">ANY</span></span><br><span class="line">WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS <span class="keyword">FOR</span> A</span><br><span class="line">PARTICULAR PURPOSE.  See the GNU General <span class="keyword">Public</span> License <span class="keyword">for</span> more details.</span><br><span class="line">使用<span class="regexp">/dev/</span>sdb</span><br><span class="line">(parted)mklabel gpt</span><br><span class="line">(parted)<span class="keyword">print</span></span><br><span class="line"><span class="regexp">/dev/</span>sdb的磁盘几何结构：<span class="number">0.000</span>-<span class="number">2048.000</span>兆字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">Minor   起始点       终止点 文件系统   名称                 标志</span><br><span class="line">(parted)mkpart primary <span class="number">0</span> <span class="number">2048</span>  &lt;-----上面<span class="keyword">print</span>显示的数字</span><br><span class="line">(parted)<span class="keyword">print</span></span><br><span class="line"><span class="regexp">/dev/</span>sdb的磁盘几何结构：<span class="number">0.000</span>-<span class="number">2048.000</span>兆字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">Minor   起始点       终止点 文件系统   名称                 标志</span><br><span class="line"><span class="number">1</span>          <span class="number">0.017</span>   <span class="number">2047.983</span></span><br><span class="line">(parted)quit</span><br></pre></td></tr></table></figure></p><h2 id="mkfs命令-磁盘格式化"><a href="#mkfs命令-磁盘格式化" class="headerlink" title="mkfs命令-磁盘格式化"></a>mkfs命令-磁盘格式化</h2><p>mkfs(make file system)磁盘格式化命令，磁盘的格式化就是给磁盘分区指定文件系统<br><figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext3 <span class="regexp">/dev/</span>hdc6</span><br></pre></td></tr></table></figure></p><h2 id="fsck命令-磁盘检验"><a href="#fsck命令-磁盘检验" class="headerlink" title="fsck命令-磁盘检验"></a>fsck命令-磁盘检验</h2><p>fsck（file system check）用来检查和维护不一致的文件系统，若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查<br><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</span></span><br><span class="line"><span class="ruby">-s : 依序一个一个地执行 fsck 的指令来检查</span></span><br><span class="line"><span class="ruby">-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查</span></span><br><span class="line"><span class="ruby">-C : 显示完整的检查进度</span></span><br><span class="line"><span class="ruby">-d : 打印出 e2fsck 的 debug 结果</span></span><br><span class="line"><span class="ruby">-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</span></span><br><span class="line"><span class="ruby">-R : 同时有 -A 条件时，省略 / 不检查</span></span><br><span class="line"><span class="ruby">-V : 详细显示模式</span></span><br><span class="line"><span class="ruby">-a : 如果检查有错则自动修复</span></span><br><span class="line"><span class="ruby">-r : 如果检查有错则由使用者回答是否修复</span></span><br><span class="line"><span class="ruby">-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 <span class="comment"># fsck -y 全部检查修复。</span></span></span><br></pre></td></tr></table></figure></p><p>强制检测 /dev/hdc6 分区:<br><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# fsck -C -f -t ext3 /dev/hdc6 </span><br><span class="line">fsck 1.39 (29-May-2006)</span><br><span class="line">e2fsck 1.39 (29-May-2006)</span><br><span class="line">Pass 1: Checking inodes, blocks, <span class="keyword">and</span> sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking<span class="built_in"> group </span>summary information</span><br><span class="line">vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks</span><br><span class="line">如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。</span><br></pre></td></tr></table></figure></p><h2 id="mount-挂载磁盘"><a href="#mount-挂载磁盘" class="headerlink" title="mount-挂载磁盘"></a>mount-挂载磁盘</h2><p>Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令，磁盘分区后即可将分区挂载到文件系统中<br><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">V：显示程序版本；</span></span><br><span class="line"><span class="ruby">-l：显示已加载的文件系统列表；</span></span><br><span class="line"><span class="ruby">-h：显示帮助信息并退出；</span></span><br><span class="line"><span class="ruby">-v：冗长模式，输出指令执行的详细信息；</span></span><br><span class="line"><span class="ruby">-n：加载没有写入文件“/etc/mtab”中的文件系统；</span></span><br><span class="line"><span class="ruby">-r：将文件系统加载为只读模式；</span></span><br><span class="line"><span class="ruby">-a：加载文件“/etc/fstab”中描述的所有文件系统</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">mount /dev/sdb1 /data</span></span><br><span class="line"><span class="ruby">umount /dev/sdb1</span></span><br></pre></td></tr></table></figure></p><h2 id="新加磁盘"><a href="#新加磁盘" class="headerlink" title="新加磁盘"></a>新加磁盘</h2><p>在生产环境中，经常遇到磁盘空间不足的情况，这时候就需要额外添加一块磁盘以增加可使用的磁盘空间，在硬件机器上插入磁盘后，可以用以下命令查看到新加的磁盘<br><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo fdisk -l</span></span><br></pre></td></tr></table></figure></p><p>接下来就需要对新加的磁盘进行分区<br><figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk <span class="regexp">/dev/</span>sdb</span><br></pre></td></tr></table></figure></p><p>/dev/sdb为新加的磁盘设备，此命令可以进入交互模式   </p><p>之后就可以通过fdisk -l查看到新建的分区/dev/sdb1,这时需要对新建的分区格式化，才能将该分区挂载到文件系统中<br><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs<span class="selector-class">.ext4</span> /dev/sdb1</span><br></pre></td></tr></table></figure></p><p>挂载该分区到文件系统中<br><figure class="hljs highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mount /dev/sdb1 /<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure></p><h2 id="分区格式"><a href="#分区格式" class="headerlink" title="分区格式"></a>分区格式</h2><p>一般硬盘的分区格式为dos,这种类型支持的分区大小最多为2T，对于大于2T的分区，需要转化为gpt格式，这里用parted程序将新加的磁盘转化为gpt格式<br>ubuntu 16.04默认安装了parted，其他没有默认安装的可以通过软件源安装，如centos系统<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> parted</span><br></pre></td></tr></table></figure></p><p>执行以下命令可以进入parted交互模式<br><figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo parted <span class="regexp">/dev/</span>sdb</span><br></pre></td></tr></table></figure></p><p>退出parted后即可用fdisk对新加的磁盘进行分区和格式化操作</p><h2 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a>lsblk命令</h2><p>lsblk命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，cd-ROM等等。lsblk命令包含在util-linux-ng包中，现在该包改名为util-linux<br><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a, --all            显示所有设备。</span></span><br><span class="line"><span class="ruby">-b, --bytes          以bytes方式显示设备大小。</span></span><br><span class="line"><span class="ruby">-d, --nodeps         不显示 slaves 或 holders。</span></span><br><span class="line"><span class="ruby">-D, --discard        print discard capabilities。</span></span><br><span class="line"><span class="ruby">-e, --exclude &lt;list&gt; 排除设备 (<span class="symbol">default:</span> RAM disks)。</span></span><br><span class="line"><span class="ruby">-f, --fs             显示文件系统信息。</span></span><br><span class="line"><span class="ruby">-h, --help           显示帮助信息。</span></span><br><span class="line"><span class="ruby">-i, --ascii          use ascii characters only。</span></span><br><span class="line"><span class="ruby">-m, --perms          显示权限信息。</span></span><br><span class="line"><span class="ruby">-l, --list           使用列表格式显示。</span></span><br><span class="line"><span class="ruby">-n, --noheadings     不显示标题。</span></span><br><span class="line"><span class="ruby">-o, --output &lt;list&gt;  输出列。</span></span><br><span class="line"><span class="ruby">-P, --pairs          使用key=<span class="string">"value"</span>格式显示。</span></span><br><span class="line"><span class="ruby">-r, --raw            使用原始格式显示。</span></span><br><span class="line"><span class="ruby">-t, --topology       显示拓扑结构信息。</span></span><br></pre></td></tr></table></figure></p><figure class="hljs highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br><span class="line"></span><br><span class="line">NAME   MAJ:MIN rm   SIZE RO type mountpoint</span><br><span class="line">sda      8:0   <span class="number"> 0 </span>232.9G <span class="number"> 0 </span>disk </span><br><span class="line">├─sda1   8:1   <span class="number"> 0 </span> 46.6G <span class="number"> 0 </span>part /</span><br><span class="line">├─sda2   8:2   <span class="number"> 0 </span>    1K <span class="number"> 0 </span>part </span><br><span class="line">├─sda5   8:5   <span class="number"> 0 </span>  190M <span class="number"> 0 </span>part /boot</span><br><span class="line">├─sda6   8:6   <span class="number"> 0 </span>  3.7G <span class="number"> 0 </span>part [SWAP]</span><br><span class="line">├─sda7   8:7   <span class="number"> 0 </span> 93.1G <span class="number"> 0 </span>part /data</span><br><span class="line">└─sda8   8:8   <span class="number"> 0 </span> 89.2G <span class="number"> 0 </span>part /personal</span><br><span class="line">sr0     11:0   <span class="number"> 1 </span> 1024M <span class="number"> 0 </span>rom</span><br></pre></td></tr></table></figure><p>7个栏目名称如下：<br>NAME：这是块设备名。<br>MAJ:MIN：本栏显示主要和次要设备号。<br>RM：本栏显示设备是否可移动设备。注意，在本例中设备sdb和sr0的RM值等于1，这说明他们是可移动设备。<br>SIZE：本栏列出设备的容量大小信息。例如298.1G表明该设备大小为298.1GB，而1K表明该设备大小为1KB。<br>RO：该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。<br>TYPE：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。<br>MOUNTPOINT：本栏指出设备挂载的挂载点。  </p><h2 id="mkswap命令"><a href="#mkswap命令" class="headerlink" title="mkswap命令"></a>mkswap命令</h2><ol><li><p>查看</p><figure class="hljs highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令free -m可以查看系统swap space大小</span><br><span class="line"></span><br><span class="line">查看当前的swap空间(<span class="keyword">file</span>(s)/<span class="keyword">partition</span>(s))：</span><br><span class="line">swapon -s</span><br><span class="line">等价于</span><br><span class="line">cat /<span class="keyword">proc</span>/swaps</span><br></pre></td></tr></table></figure></li><li><p>添加交换空间</p></li></ol><p>添加一个交换分区或添加一个交换文件。推荐你添加一个交换分区；不过，若你没有多少空闲空间可用，则添加交换文件。<br><figure class="hljs highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">添加一个交换分区，步骤如下：</span><br><span class="line">使用fdisk来创建交换分区（假设 <span class="string">/dev/sdb2</span> 是创建的交换分区），使用 mkswap 命令来设置交换分区：</span><br><span class="line">mkswap <span class="string">/dev/sdb2</span></span><br><span class="line">启用交换分区：</span><br><span class="line">swapon <span class="string">/dev/sdb2</span></span><br><span class="line">写入<span class="string">/etc/fstab</span>，以便在引导时启用：</span><br><span class="line"><span class="string">/dev/sdb2</span> swap swap defaults 0 0</span><br><span class="line"></span><br><span class="line">添加一个交换文件，步骤如下：</span><br><span class="line">创建大小为512M的交换文件：</span><br><span class="line">dd <span class="keyword">if</span>=<span class="string">/dev/zero</span> of=<span class="string">/swapfile1</span> bs=1024 count=524288</span><br><span class="line">使用mkswap命令来设置交换文件：</span><br><span class="line">mkswap <span class="string">/swapfile1</span></span><br><span class="line">启用交换分区：</span><br><span class="line">swapon <span class="string">/swapfile1</span></span><br><span class="line">写入<span class="string">/etc/fstab</span>，以便在引导时启用：</span><br><span class="line"><span class="string">/swapfile1</span> swap swap defaults 0 0</span><br><span class="line">新添了交换分区并启用它之后，请查看cat <span class="string">/proc/swaps</span>或free命令的输出来确保交换分区已被启用了</span><br></pre></td></tr></table></figure></p><ol start="3"><li>删除/禁用交换空间：<figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff <span class="regexp">/dev/</span>sdb2</span><br><span class="line">从<span class="regexp">/etc/</span>fstab中删除项目，使用fdisk或yast工具删除分区</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;df命令&quot;&gt;&lt;a href=&quot;#df命令&quot; class=&quot;headerlink&quot; title=&quot;df命令&quot;&gt;&lt;/a&gt;df命令&lt;/h2&gt;&lt;figure class=&quot;hljs highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;a或--all：包含全部的文件系统；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;--block-size=&amp;lt;区块大小&amp;gt;：以指定的区块大小来显示区块数目；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-h或--human-readable：以可读性较高的方式来显示信息；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-H或--si：与-h参数相同，但在计算时是以&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; Bytes为换算单位而非&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; Bytes；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-i或--inodes：显示inode的信息；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-k或--kilobytes：指定区块大小为&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;字节；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-l或--local：仅显示本地端的文件系统；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-m或--megabytes：指定区块大小为&lt;span class=&quot;number&quot;&gt;1048576&lt;/span&gt;字节；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-P或--portability：使用POSIX的输出格式；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;--sync：在取得磁盘使用信息前，先执行sync指令；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-t&amp;lt;文件系统类型&amp;gt;或--type=&amp;lt;文件系统类型&amp;gt;：仅显示指定文件系统类型的磁盘信息；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-T或--print-type：显示文件系统的类型；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;-x&amp;lt;文件系统类型&amp;gt;或--exclude-type=&amp;lt;文件系统类型&amp;gt;：不要显示指定文件系统类型的磁盘信息；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;--help：显示帮助；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ruby&quot;&gt;--version：显示版本信息。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
    
      <category term="磁盘管理" scheme="http://www.lizq.top/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="http://www.lizq.top/2017/10/18/CS/Linux/vim/"/>
    <id>http://www.lizq.top/2017/10/18/CS/Linux/vim/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li>i 在光标处插入字符</li><li>a 在光标后插入</li><li>o 在当前行下面插入新行，并进入插入模式</li><li>dd 删除当前整行</li><li>yy 复制当前行</li><li>nyy 复制当前行之后的n行</li><li>p 粘贴</li><li>u 撤销</li><li>r 替换当前字符</li><li>x 删除当前光标所在处的字符</li><li>/ 查找关键字 按n键可在匹配的内容之间不停的切换<a id="more"></a></li></ul><h3 id="移动光标的方法"><a href="#移动光标的方法" class="headerlink" title="移动光标的方法"></a>移动光标的方法</h3><ul><li>h或左箭头，向指定方向移动一个字符（j或下箭头，k或上箭头，l或右箭头）</li><li>6l， 向右移动6个字符</li><li>5<space> 向右移动这一行的5个字符</space></li><li>5<enter> 向下移动5行</enter></li><li>w(向右移动到下一个单词的首个字符)，e(向右移动到下一个单词的最后一个字符)，b(向左移动到下一个单词的首个字符)</li><li>5w, 向右移动5个单词</li><li>0或[home], 移动到这一行的第一个字符</li><li>$或[end], 移动到这一行的最后一个字符</li><li>ctrl+f, [page down], 屏幕向下移动一页，ctrl+b, [page up], 屏幕向上移动一页</li><li>ctrl+d, 屏幕向下移动半页， ctrl+u, 屏幕下上移动半页</li><li>H,光标移动到当前屏幕最上方那一行的首个字符; M,移动到当前屏幕中央那一行的首个字符; L,移动到当前屏幕最下方那一行的首个字符</li><li>G，移动到当前文件的最后一行; nG,移动到这个文件的第n行; gg(1G)，移动到这个文件的第一行</li></ul><h3 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h3><ul><li>/word  向光标之下寻找一个名称为 word 的字符串</li><li>?word  向光标之上寻找一个名称为 word 的字符串</li><li>n      这个 n 是英文按键。代表『重复前一个搜寻的动作』。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串</li><li>N      这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird </li><li>:n1,n2s/word1/word2/g   n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2</li><li>:1,$s/word1/word2/g   从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2</li><li>:1,$s/word1/word2/gc  从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代</li></ul><h3 id="删除、复制与粘贴"><a href="#删除、复制与粘贴" class="headerlink" title="删除、复制与粘贴"></a>删除、复制与粘贴</h3><ul><li>x, 删除，相当于delete, nx,向后删除n个字符</li><li>dd, ndd 删除整行</li><li>d1G，删除光标所在行到第一行</li><li>dG，删除光标所在行到最后一行</li><li>d$，删除光标所在位置到该行最后一个字符</li><li>d0，删除光标所在位置到该行第一个字符</li><li>yy, nyy 复制整行</li><li>y1G, 复制光标所在行到第一行</li><li>yG, 复制光标所在行到最后一行</li><li>y$，复制光标所在位置到该行最后一个字符</li><li>y0，复制光标所在位置到该行第一个字符</li><li>p, 在光标下一行粘贴，P，在光标上一行粘贴</li><li>J 将光标所在行与下一列的数据结合成同一行</li><li>u 撤销</li><li>ctrl+r 重复上一个动作</li><li>. 重复前一个动作</li></ul><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><table><thead><tr><th>命令行模式</th><th></th></tr></thead><tbody><tr><td>:w</td><td>保存当前修改</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出，不保存修改</td></tr><tr><td>:x</td><td>保存并退出，相当于:wq</td></tr><tr><td>:set number</td><td>显示行号</td></tr><tr><td>:!</td><td>系统命令 执行一个系统命令，并显示结果</td></tr><tr><td>:sh</td><td>切换到命令行，使用ctrl+d返回vim</td></tr><tr><td>:w [filename]</td><td>将编辑数据保存为另一文件，相当于另存为</td></tr><tr><td>:r [filename]</td><td>在编辑数据中，读入另一文件的数据，将filename这个文件的内容加到光标所在行的后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将当前文件的n1到n2行内容保存到filename这个文件里</td></tr></tbody></table><h3 id="常用设定"><a href="#常用设定" class="headerlink" title="常用设定"></a>常用设定</h3><ul><li>set number: 显示行号</li><li>set cindent: 设定c风格缩进，可使用nocindent取消设定</li><li>set autoindent: 设定自动缩进，每行缩进与上一行相等，可使用noautoindent取消设定</li><li>set shiftwidth=2: 设定缩进为2个空格</li><li>set tabstop=2: 设定tab制表符为2个空格</li><li>set softtabstop=2: 设定软制表符为2个空格</li><li>set expandtab=2: 缩进和软制表符使用空格替代，可用noexpandtab取消设定</li><li>set ruler: 显示光标所在列号</li><li>set mouse=v: 启用鼠标右键复制功能，默认mouse=a,屏蔽鼠标右键功能</li><li>syntax on : 启用语法高亮</li></ul><h2 id="Vim插件"><a href="#Vim插件" class="headerlink" title="Vim插件"></a>Vim插件</h2><ul><li>taglist</li><li>ctags</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;i 在光标处插入字符&lt;/li&gt;
&lt;li&gt;a 在光标后插入&lt;/li&gt;
&lt;li&gt;o 在当前行下面插入新行，并进入插入模式&lt;/li&gt;
&lt;li&gt;dd 删除当前整行&lt;/li&gt;
&lt;li&gt;yy 复制当前行&lt;/li&gt;
&lt;li&gt;nyy 复制当前行之后的n行&lt;/li&gt;
&lt;li&gt;p 粘贴&lt;/li&gt;
&lt;li&gt;u 撤销&lt;/li&gt;
&lt;li&gt;r 替换当前字符&lt;/li&gt;
&lt;li&gt;x 删除当前光标所在处的字符&lt;/li&gt;
&lt;li&gt;/ 查找关键字 按n键可在匹配的内容之间不停的切换
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
      <category term="vim" scheme="http://www.lizq.top/categories/CS/linux/vim/"/>
    
    
      <category term="vim" scheme="http://www.lizq.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="http://www.lizq.top/2017/08/11/CS/Linux/ssh/"/>
    <id>http://www.lizq.top/2017/08/11/CS/Linux/ssh/</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH-service"><a href="#SSH-service" class="headerlink" title="SSH service"></a>SSH service</h2><ul><li><p>install sshd </p><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>configuration<br>/etc/ssh/sshd_config</p><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Authentication:</span></span><br><span class="line"><span class="string">LoginGraceTime</span> <span class="number">120</span></span><br><span class="line"><span class="comment"># PermitRootLogin prohibit-password</span></span><br><span class="line"><span class="string">PermitRootLogin</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">StrictModes</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="Generate-public-key"><a href="#Generate-public-key" class="headerlink" title="Generate public key"></a>Generate public key</h2><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SSH-service&quot;&gt;&lt;a href=&quot;#SSH-service&quot; class=&quot;headerlink&quot; title=&quot;SSH service&quot;&gt;&lt;/a&gt;SSH service&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;install sshd &lt;/p&gt;
&lt;figure class=&quot;hljs highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; install openssh-server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;configuration&lt;br&gt;/etc/ssh/sshd_config&lt;/p&gt;
&lt;figure class=&quot;hljs highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Authentication:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;LoginGraceTime&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# PermitRootLogin prohibit-password&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;PermitRootLogin&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;StrictModes&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
    
      <category term="ssh" scheme="http://www.lizq.top/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>文本处理</title>
    <link href="http://www.lizq.top/2017/08/11/CS/Linux/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    <id>http://www.lizq.top/2017/08/11/CS/Linux/文本处理/</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep用于基于关键字搜索文本，可以结合管道符使用     # grep test /etc/passwd<br>grep命令的一些数</p><ul><li>-i 搜索时忽略大小写</li><li>-n 显示结果所在行数</li><li>-v 输出不带关键字的行，取反操作</li><li>-Ax 输出关键字所在的后几行       #grep -A3 test /etc/passwd </li><li>-Bx 输出关键字所在的前几行</li><li>-d 指定分隔符，默认时tab</li><li>-f 指定输出的<a id="more"></a></li></ul><h2 id="cut用以基于列处理文本"><a href="#cut用以基于列处理文本" class="headerlink" title="cut用以基于列处理文本"></a>cut用以基于列处理文本</h2><p>cut -d: -f1 /etc/passwd<br>cut -c2-6 /etc/passwd    </p><ul><li>-d 指定分割字符（默认为tab)</li><li>-f 指定输出的列号</li><li>-c 基于字符进行切割</li></ul><h2 id="wc文本统计"><a href="#wc文本统计" class="headerlink" title="wc文本统计"></a>wc文本统计</h2><p>wc {filename}</p><ul><li>-l 只统计行数</li><li>-w 只统计单词数</li><li>-c 只统计字节数</li><li>-m 只统计字符数</li></ul><h2 id="sort文本排序"><a href="#sort文本排序" class="headerlink" title="sort文本排序"></a>sort文本排序</h2><ul><li>-r 进行倒序排序</li><li>-n 基于数字进行排序</li><li>-f 忽略大小写</li><li>-u 删除重复行</li><li>-t c 使用c作为分隔符分割为列进行排序</li><li>-k x 当进行基于指定字符分割为列的排序时，指定基于那个列排序</li></ul><h2 id="删除重复行"><a href="#删除重复行" class="headerlink" title="删除重复行"></a>删除重复行</h2><ul><li>命令sort -u 可以删除重复行</li><li>命令uniq用以删除重复的相邻行</li></ul><h2 id="diff文本比较"><a href="#diff文本比较" class="headerlink" title="diff文本比较"></a>diff文本比较</h2><p>diff file1 file2</p><ul><li>-i 忽略大小写</li><li>-b 忽略空格数量的变化</li><li>-u 统一显示比较信息（一般用以生成patch文件）<figure class="hljs highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -u file1 file2 &gt; <span class="keyword">final</span>.patch</span><br></pre></td></tr></table></figure></li></ul><h2 id="tr文本处理"><a href="#tr文本处理" class="headerlink" title="tr文本处理"></a>tr文本处理</h2><ul><li>删除关键字 tr -d ‘asd’ &lt; file1</li><li>转换大小写 tr ‘a-z’ ‘A-Z’ &lt; file1</li></ul><h2 id="sed搜索替换"><a href="#sed搜索替换" class="headerlink" title="sed搜索替换"></a>sed搜索替换</h2><figure class="hljs highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sed [-nefr] [n1,n2] action</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">-n: 是安静模式，只有经过sed处理过的行才显示出来</span><br><span class="line">-e：表示直接在命令行模式上进行sed的操作，默认选项，不用写</span><br><span class="line">-f：将sed的操作写在一个文件里，-f filename可以按照内容进行sed操作</span><br><span class="line">-r：表示sed支持扩展正则表达式</span><br><span class="line">n1,n2: 不一定需要，选择要处理的行</span><br><span class="line">sed的action支持以下操作参数</span><br><span class="line">a：表示添加，后接字符串，添加到当前的下一行</span><br><span class="line">c：表示替换，后接字符串，用它替换n1到n2之间的行</span><br><span class="line">d：表示删除符合模式的行，它的语法为sed <span class="string">'/regexp/d'</span>,模式在d之前，d后面一般不接任何内容</span><br><span class="line">i：表示插入，后接字符串，添加到当前行的上一行</span><br><span class="line">p：表示打印，打印某个选择的数据，通常与-n安静模式一起使用</span><br><span class="line"><span class="keyword">s</span>：表示搜索，还可以替换，类似于vim里的搜索替换功能，例如：<span class="number">1</span>,<span class="number">20</span>/<span class="regexp">s/old/new/g</span>表示替换<span class="number">1</span>-<span class="number">20</span>行的old为new，g表示处理这一行所有匹配的内容</span><br><span class="line"><span class="comment"># action最好用''括起来，防止因空格导致错误</span></span><br></pre></td></tr></table></figure><ul><li>sed ‘s/linux/windows/g’ file1  # 将文件file1中的linux全部转换为windows</li><li>sed ‘1,50s/linux/windows/g’ file1  # 将文件file1中1到50行中的linux全部转换为windows</li><li>sed -e ‘s/linux/windows/g’ -e ‘s/test/demo/g’ file1   # -e参数指定多个替换选项</li><li>sed -f sedfile file1   # 可以将’s/linux/windows/g’等匹配字符写入文件，并用-f参数指定该文件进行匹配替换</li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><figure class="hljs highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="symbol">'BEGIN</span>&#123; statements &#125; statements2 <span class="keyword">END</span>&#123; statements &#125;'</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.执行<span class="keyword">begin</span>中语句块；</span><br><span class="line"><span class="number">2</span>.从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；</span><br><span class="line"><span class="number">3</span>.执行<span class="keyword">end</span>语句块；</span><br></pre></td></tr></table></figure><figure class="hljs highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用不带参数的<span class="built_in">print</span>时，打印当前行</span><br><span class="line">echo -e <span class="string">"line1\nline2"</span> | awk 'BEGIN&#123;<span class="built_in">print</span> <span class="string">"start"</span>&#125; &#123;<span class="built_in">print</span> &#125; END&#123; <span class="built_in">print</span> <span class="string">"End"</span> &#125;'</span><br><span class="line"># <span class="built_in">print</span> 以逗号分割时，参数以空格定界</span><br><span class="line">echo | awk ' &#123;<span class="built_in">var1</span> = <span class="string">"v1"</span> ; var2 = <span class="string">"V2"</span>; var3=<span class="string">"v3"</span>; <span class="built_in">print</span> <span class="built_in">var1</span>, var2 , var3; &#125;'</span><br><span class="line">$&gt;v1 V2 v3</span><br></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">特殊变量： NR NF <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line">NR:表示记录数量，在执行过程中对应当前行号；</span><br><span class="line">NF:表示字段数量，在执行过程总对应当前行的字段数；</span><br><span class="line"><span class="variable">$0</span>:这个变量包含执行过程中当前行的文本内容；</span><br><span class="line"><span class="variable">$1</span>:第一个字段的文本内容；</span><br><span class="line"><span class="variable">$2</span>:第二个字段的文本内容；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每一行的第二和第三个字段</span></span><br><span class="line">awk <span class="string">'&#123;print $2, $3&#125;'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件的行数</span></span><br><span class="line">awk <span class="string">' END &#123;print NR&#125;'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累加每一行的第一个字段</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"1\n 2\n 3\n 4\n"</span> | awk <span class="string">'BEGIN&#123;num = 0 ;</span></span><br><span class="line"><span class="string">print "begin";&#125; &#123;sum += $1;&#125; END &#123;print "=="; print sum &#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递外部变量</span></span><br><span class="line">var=1000</span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123;print vara&#125;'</span> vara=<span class="variable">$var</span> <span class="comment">#  输入来自stdin</span></span><br><span class="line">awk <span class="string">'&#123;print vara&#125;'</span> vara=<span class="variable">$var</span> file <span class="comment"># 输入来自文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用样式对awk处理的行进行过滤</span></span><br><span class="line">awk <span class="string">'NR &lt; 5'</span> <span class="comment">#行号小于5</span></span><br><span class="line">awk <span class="string">'NR==1,NR==4 &#123;print&#125;'</span> file <span class="comment">#行号等于1和4的打印出来</span></span><br><span class="line">awk <span class="string">'/linux/'</span> <span class="comment">#包含linux文本的行（可以用正则表达式来指定，超级强大）</span></span><br><span class="line">awk <span class="string">'!/linux/'</span> <span class="comment">#不包含linux文本的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-F来设置定界符（默认为空格）</span></span><br><span class="line">awk -F: <span class="string">'&#123;print $NF&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><h2 id="迭代文件中的行、单词和字符"><a href="#迭代文件中的行、单词和字符" class="headerlink" title="迭代文件中的行、单词和字符"></a>迭代文件中的行、单词和字符</h2><p>1.迭代文件中的每一行<br><figure class="hljs highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">while</span> 循环法</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">read</span> <span class="keyword">line</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo <span class="variable">$line</span>;</span><br><span class="line">done &lt; <span class="keyword">file</span>.txt</span><br><span class="line"></span><br><span class="line"># 改成子<span class="keyword">shell</span>:</span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | (<span class="keyword">while</span> <span class="keyword">read</span> <span class="keyword">line</span>;<span class="keyword">do</span> echo <span class="variable">$line</span>;done)</span><br><span class="line"></span><br><span class="line"># awk法</span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt| awk '&#123;<span class="keyword">print</span>&#125;'</span><br></pre></td></tr></table></figure></p><p>2.迭代一行中的每一个单词<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable">$line</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$word</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>3.迭代每一个字符<br><figure class="hljs highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span><span class="symbol">string:</span><span class="symbol">start_pos:</span>num_of_chars&#125;：从字符串中提取一个字符；(bash文本切片）</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;</span><span class="comment">#word&#125;:返回变量word的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="variable">$&#123;</span><span class="comment">#word&#125;;i++))</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo <span class="variable">$&#123;</span><span class="symbol">word:</span><span class="symbol">i:</span><span class="number">1</span>);</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;&lt;p&gt;grep用于基于关键字搜索文本，可以结合管道符使用     # grep test /etc/passwd&lt;br&gt;grep命令的一些数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i 搜索时忽略大小写&lt;/li&gt;
&lt;li&gt;-n 显示结果所在行数&lt;/li&gt;
&lt;li&gt;-v 输出不带关键字的行，取反操作&lt;/li&gt;
&lt;li&gt;-Ax 输出关键字所在的后几行       #grep -A3 test /etc/passwd &lt;/li&gt;
&lt;li&gt;-Bx 输出关键字所在的前几行&lt;/li&gt;
&lt;li&gt;-d 指定分隔符，默认时tab&lt;/li&gt;
&lt;li&gt;-f 指定输出的
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
    
      <category term="文本处理" scheme="http://www.lizq.top/tags/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab Cluster</title>
    <link href="http://www.lizq.top/2017/06/01/CS/Git/gitlab_cluster/"/>
    <id>http://www.lizq.top/2017/06/01/CS/Git/gitlab_cluster/</id>
    <published>2017-05-31T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitlab集群"><a href="#Gitlab集群" class="headerlink" title="Gitlab集群"></a>Gitlab集群</h1><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>总共架构由5部分组成</p><ul><li>Postgresql</li><li>Redis</li><li>Gitlab</li><li>NFS</li><li>LB</li></ul><p><img src="https://docs.gitlab.com/ce/administration/img/high_availability/active-active-diagram.png" alt="Configuration"><br><a id="more"></a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Gitlab官网上的文档说到的方案是搭建一个稳定高可用性的Redis集群，我在这里做了简化，只用docker搭建了单个节点的Redis服务<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -dti <span class="comment">--name redis -p 6379:6379 redis</span></span><br></pre></td></tr></table></figure></p><p>Redis服务的主机IP和端口号将在gitlab配置中用到</p><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>Posstgresql服务是利用postgresql官方提供的docker镜像搭建的，执行命令如下<br><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name db -dti -p 5432:5432 -e <span class="attribute">POSTGRES_PASSWORD</span>=123456 -e <span class="attribute">POSTGRES_USER</span>=gitlab postgres</span><br></pre></td></tr></table></figure></p><p>Postgresql服务的主机IP，端口，数据库用户名，数据库名称和密码也将在gitlab的配置中用到</p><ul><li>注：这里postgresql镜像使用的postgresql版本建议和下面使用到的gitlab自带的postgresql数据库版本一致，方便之后的数据迁移</li></ul><h2 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h2><p>根据需求，使用了Gitlab最新版本的官方docker镜像在不同的主机上搭建gitlab服务，最新版本为gitlab:9.4.2</p><ul><li><p>首先在host1新建一个文件夹/root/git-data,用作运行在docker上gitlab容器的数据卷,该数据卷存储的是gitlab中repositories的数据</p><figure class="hljs highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">    -<span class="ruby">-publish <span class="number">80</span><span class="symbol">:</span><span class="number">80</span> \</span></span><br><span class="line"><span class="ruby">    --name gitlab4 \</span></span><br><span class="line"><span class="ruby">    --restart always \</span></span><br><span class="line"><span class="ruby">    --volume /root/git-<span class="symbol">data:</span>/var/opt/gitlab/git-data \</span></span><br><span class="line"><span class="ruby">    <span class="symbol">gitlab:</span><span class="number">9.4</span>.<span class="number">2</span></span></span><br></pre></td></tr></table></figure></li><li><p>运行gitlab的docker镜像之后，等待一两分钟gitlab将会启动配置好，将可以在host1在80端口访问gitlab等登录界面。之后docker exec 进入容器，编辑/etc/gitlab/gitlab.rb配置文件，如下</p><figure class="hljs highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">'db_adapter'</span>] = <span class="string">"postgresql"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_encoding'</span>] = <span class="string">"unicode"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_database'</span>] = <span class="string">"gitlab"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_pool'</span>] = <span class="number">10</span></span><br><span class="line">gitlab_rails[<span class="string">'db_username'</span>] = <span class="string">"gitlab"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_password'</span>] = <span class="string">"123456"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_host'</span>] = <span class="string">"&#123;ip&#125;"</span></span><br><span class="line">gitlab_rails[<span class="string">'db_port'</span>] = <span class="number">5432</span></span><br><span class="line">gitlab_rails[<span class="string">'redis_host'</span>] = <span class="string">"&#123;ip&#125;"</span></span><br><span class="line">gitlab_rails[<span class="string">'redis_port'</span>] = <span class="number">6379</span></span><br><span class="line">gitlab_rails[<span class="string">'redis_database'</span>] = <span class="number">0</span></span><br><span class="line">postgresql[<span class="string">'enable'</span>] = false</span><br><span class="line">redis[<span class="string">'enable'</span>] = false</span><br><span class="line">nginx[<span class="string">'enable'</span>] = true</span><br><span class="line">nginx[<span class="string">'redirect_http_to_https'</span>] = true</span><br></pre></td></tr></table></figure></li></ul><p>/etc/gitlab/gitlab.rb配置文件中的Redis和Postgresql信息应该与之前搭建的服务一致，之后运行以下命令配置gitlab服务<br><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gitlab-ctl reconfigure</span></span><br></pre></td></tr></table></figure></p><ul><li>之后可以在更多的主机上按照以上步骤搭建gitlab服务，比如host2，host3。每一个主机上的gitlab服务都共用Redis和Postgresql,因此可以保证账户，密码和配置数据的一致，但是gitlab还有repositories数据是存放在/var/opt/gitlab/git-data文件夹下的，也就是宿主机的数据卷/root/git-data中，所以我们还需要对每台主机上的/root/git-data/文件夹做数据同步，这里我们搭建NFS来实现</li></ul><h2 id="NFS服务"><a href="#NFS服务" class="headerlink" title="NFS服务"></a>NFS服务</h2><p>我们利用NFS服务实现多台主机上的文件同步, 可以任选一台搭建了gitlab服务的主机作为NFS Server，并将该主机上的/root/git-data文件夹对其他主机exports,供其他主机的文件系统挂载到NFS Server这台主机上的/root/git-data文件夹，从而实现文件同步</p><ul><li>在NFS Server主机上安装nfs server服务</li></ul><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> update</span><br><span class="line">apt-<span class="builtin-name">get</span> install nfs-kernel-server  # install nfs server</span><br><span class="line"></span><br><span class="line">chown nobody:nogroup /root/git-data   # modify dir owner</span><br></pre></td></tr></table></figure><ul><li>编辑nfs server配置文件/etc/exports</li></ul><figure class="hljs highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/git-<span class="class"><span class="keyword">data</span>  *(<span class="title">rw</span>,<span class="title">sync</span>,<span class="title">no_root_squash</span>,<span class="title">no_subtree_check</span>)</span></span><br></pre></td></tr></table></figure><p>* 表示任意主机，rw表示读写读写权限，sync表示文件修改将写入硬盘，no_subtree_check禁止子文件夹检查，no_root_squash禁止客户端的root用户在服务器端使用root权限</p><ul><li>重启nfs-kernel-server服务</li></ul><figure class="hljs highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nfs-kernel-<span class="keyword">server</span> restart</span><br></pre></td></tr></table></figure><ul><li>在nfs clinet主机上安装nfs 客户端程序</li></ul><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> update</span><br><span class="line">apt-<span class="builtin-name">get</span> install nfs-common</span><br></pre></td></tr></table></figure><ul><li>将nfs client主机上的文件夹挂载到nfs server主机上需要文件同步的文件夹上</li></ul><figure class="hljs highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#123;nfs-server-ip&#125;<span class="symbol">:/root/git-data</span> /root/git-data</span><br></pre></td></tr></table></figure><h2 id="Gitlab数据备份与恢复"><a href="#Gitlab数据备份与恢复" class="headerlink" title="Gitlab数据备份与恢复"></a>Gitlab数据备份与恢复</h2><ul><li>备份</li></ul><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:<span class="keyword">backup</span>:<span class="keyword">create</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Or</span></span><br><span class="line">docker exec -t &lt;<span class="keyword">container</span> <span class="keyword">name</span>&gt; gitlab-rake gitlab:<span class="keyword">backup</span>:<span class="keyword">create</span></span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><figure class="hljs highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> <span class="number">1493107454</span>_2017_04_25_9.<span class="number">1.0</span>_gitlab_backup.tar /var/<span class="keyword">opt</span>/gitlab/backups/  # <span class="keyword">put</span> baskup <span class="keyword">file</span> under given dir</span><br><span class="line"></span><br><span class="line">gitlab-ctl <span class="keyword">stop</span> unicorn</span><br><span class="line">gitlab-ctl <span class="keyword">stop</span> sidekiq</span><br><span class="line">gitlab-ctl status</span><br><span class="line"></span><br><span class="line">gitlab-rake gitla<span class="variable">b:backup</span>:restore BACKUP=<span class="number">1493107454</span>_2017_04_25_9.<span class="number">1.0</span></span><br><span class="line">gitlab-ctl start</span><br><span class="line">gitlab-rake gitla<span class="variable">b:check</span> SANITIZE=true</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li>编辑nginx配置文件/etc/nginx/nginx.conf    </li></ul><figure class="hljs highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream <span class="keyword">myapp</span> &#123;</span><br><span class="line">    server &#123;<span class="literal">ip</span>&#125;:8080;</span><br><span class="line">    <span class="keyword">server</span> &#123;<span class="literal">ip</span>&#125;:5432;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name &#123;<span class="literal">ip</span>&#125;;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header HOST <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_pass http://myapp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>清除redis缓存     </li></ol><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake cache:clear <span class="attribute">RAILS_ENV</span>=production</span><br></pre></td></tr></table></figure><figure class="hljs highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab2 -p <span class="number">8099</span>:<span class="number">80</span> -v <span class="regexp">/home/</span>lzq<span class="regexp">/git-config2/</span><span class="string">gitlab:</span><span class="regexp">/etc/</span>gitlab -v <span class="regexp">/home/</span>lzq<span class="regexp">/gitlab-data2:/</span>gitlab-data twang2218/gitlab-ce-<span class="string">zh:</span><span class="number">9.4</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gitlab集群&quot;&gt;&lt;a href=&quot;#Gitlab集群&quot; class=&quot;headerlink&quot; title=&quot;Gitlab集群&quot;&gt;&lt;/a&gt;Gitlab集群&lt;/h1&gt;&lt;h2 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h2&gt;&lt;p&gt;总共架构由5部分组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Postgresql&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Gitlab&lt;/li&gt;
&lt;li&gt;NFS&lt;/li&gt;
&lt;li&gt;LB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.gitlab.com/ce/administration/img/high_availability/active-active-diagram.png&quot; alt=&quot;Configuration&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="application" scheme="http://www.lizq.top/categories/CS/application/"/>
    
      <category term="gitlab" scheme="http://www.lizq.top/categories/CS/application/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://www.lizq.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Shell流程控制</title>
    <link href="http://www.lizq.top/2017/01/19/CS/Linux/shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.lizq.top/2017/01/19/CS/Linux/shell流程控制/</id>
    <published>2017-01-18T16:00:00.000Z</published>
    <updated>2019-04-14T06:31:38.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 大于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 小于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"没有符合的条件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The value is: <span class="variable">$loop</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="hljs highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">str</span> <span class="built_in">in</span> <span class="string">'This is a string'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> $<span class="built_in">str</span></span><br><span class="line">don</span><br></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=1;i&lt;=10;i++))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">echo</span> $(expr <span class="variable">$i</span> \* 4)</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><figure class="hljs highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> condition</span><br><span class="line"><span class="built_in">do</span></span><br><span class="line">    <span class="keyword">command</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'输入 1 到 4 之间的数字:'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'你输入的数字为:'</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">'你选择了 1'</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">'你选择了 2'</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">'你选择了 3'</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">'你选择了 4'</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">'你没有输入 1 到 4 之间的数字'</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><ul><li><p>break</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字:"</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>continue</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的!"</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"游戏结束"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这个函数会对输入的两个数字进行相加运算..."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第一个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第二个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !"</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"输入的两个数字之和为 $? !"</span></span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 <span class="variable">$1</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 <span class="variable">$2</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$10</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$&#123;10&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 <span class="variable">$&#123;11&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 <span class="variable">$#</span> 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 $* !"</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line"><span class="variable">$#</span>传递到脚本的参数个数</span><br><span class="line">$*以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$$脚本运行的当前进程ID号</span><br><span class="line">$!后台运行的最后一个进程的ID号</span><br><span class="line"><span class="variable">$@</span>与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-显示Shell使用的当前选项，与<span class="built_in">set</span>命令功能相同。</span><br><span class="line">$?显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;if-else&quot;&gt;&lt;a href=&quot;#if-else&quot; class=&quot;headerlink&quot; title=&quot;if-else&quot;&gt;&lt;/a&gt;if-else&lt;/h3&gt;&lt;figure class=&quot;hljs highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b=20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;variable&quot;&gt;$a&lt;/span&gt; == &lt;span class=&quot;variable&quot;&gt;$b&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;a 等于 b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; [ &lt;span class=&quot;variable&quot;&gt;$a&lt;/span&gt; -gt &lt;span class=&quot;variable&quot;&gt;$b&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;a 大于 b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; [ &lt;span class=&quot;variable&quot;&gt;$a&lt;/span&gt; -lt &lt;span class=&quot;variable&quot;&gt;$b&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;a 小于 b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;没有符合的条件&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CS" scheme="http://www.lizq.top/categories/CS/"/>
    
      <category term="linux" scheme="http://www.lizq.top/categories/CS/linux/"/>
    
      <category term="shell" scheme="http://www.lizq.top/categories/CS/linux/shell/"/>
    
    
      <category term="shell" scheme="http://www.lizq.top/tags/shell/"/>
    
  </entry>
  
</feed>
